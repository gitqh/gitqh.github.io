<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="qh's blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="收集的Java经典面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试题">
<meta property="og:url" content="http://gitqh.github.io/2017/09/11/Java_Interview/index.html">
<meta property="og:site_name" content="qh&#39;s blog">
<meta property="og:description" content="收集的Java经典面试题">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2017-09-28T04:52:53.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java面试题">
<meta name="twitter:description" content="收集的Java经典面试题">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://gitqh.github.io/2017/09/11/Java_Interview/"/>





  <title>Java面试题 | qh's blog</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">qh's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">think twice before action</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gitqh.github.io/2017/09/11/Java_Interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qh's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java面试题</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-11T15:17:34+08:00">
                2017-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index">
                    <span itemprop="name">interview</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>收集的Java经典面试题</p>
<hr>
<a id="more"></a>
<h2 id="Java关键字final、static使用总结"><a href="#Java关键字final、static使用总结" class="headerlink" title="Java关键字final、static使用总结"></a>Java关键字final、static使用总结</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ul>
<li>final：终态，可以修饰非抽象类、非抽象类成员方法和变量</li>
<li>final类：不能被继承，没有子类，final类中的方法默认是final的。如果一个类不需要有子类，且类的实现细节不允许改变，并且这个<br>类不会被扩展，可以设计为final类</li>
<li>final方法：不能被子类的方法覆盖，可以被继承。final方法使用原因：锁定方法，防止继承类修改；高效，编译器遇到final方法会转入内嵌机制，提高执行效率</li>
<li>final成员变量：常量，只能被赋值一次，赋值后值不再改变</li>
<li>final参数：可以读取该参数，但无法改变该参数的值</li>
<li>注意：final不能用于修饰构造方法，private类型的方法默认是final类型的<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3></li>
<li>static：全局或静态</li>
<li>static：成员变量与成员方法：被类所有实例共享，静态变量在内存中只有一个拷贝，节省内存</li>
<li>static方法：静态方法，方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法</li>
<li>static代码块：JVM加载类时会执行，多处代码块会按照在类中出现的先后顺序依次执行<h3 id="static-final"><a href="#static-final" class="headerlink" title="static final"></a>static final</h3></li>
<li>static final变量：全局常量</li>
<li>static final方法：方法不可覆盖</li>
</ul>
<h2 id="匿名内部类是什么？如何访问在其外面定义的变量。"><a href="#匿名内部类是什么？如何访问在其外面定义的变量。" class="headerlink" title="匿名内部类是什么？如何访问在其外面定义的变量。"></a>匿名内部类是什么？如何访问在其外面定义的变量。</h2><p>访问在其外面的变量，必须通过关键字final作为形参传入<br>拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，所以用final来让该引用不可改变</p>
<h3 id="匿名内部类的创建"><a href="#匿名内部类的创建" class="headerlink" title="匿名内部类的创建"></a>匿名内部类的创建</h3><p>new 父类构造器（参数列表）|实现接口（）<br>    {<br>     //匿名内部类的类体部分<br>    }</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>只用到类的一个实例</li>
<li>类在定义后马上用到</li>
<li>类非常小（sun推荐代码一下）</li>
<li>给类命名并不会导致代码更容易被理解<h3 id="使用原则"><a href="#使用原则" class="headerlink" title="使用原则"></a>使用原则</h3></li>
<li>不能有构造方法</li>
<li>不能定义静态成员、方法和类</li>
<li>匿名内部类不能是public，protected，private，static</li>
<li>只能创建一个实例</li>
<li>一个匿名内部类一定在new后面，用其隐含实现一个接口或一个类</li>
<li>匿名内部类为局部内部类，所以局部内部类的所有限制都对其生效<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3>通过代码块完成初始化<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OutClass</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> InnerClass <span class="title">getInnerClass</span>(<span class="params">final <span class="keyword">int</span> age,final String name</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InnerClass() &#123;</div><div class="line">            <span class="keyword">int</span> age_ ;</div><div class="line">            String name_;</div><div class="line">            <span class="comment">//构造代码块完成初始化工作</span></div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(&lt; age &amp;&amp; age &lt; &#123;</div><div class="line">                    age_ = age;</div><div class="line">                    name_ = name;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> name_;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> age_;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">        OutClass <span class="keyword">out</span> = <span class="keyword">new</span> OutClass();</div><div class="line">        InnerClass inner_= <span class="keyword">out</span>.getInnerClass( <span class="string">"chenssy"</span>);</div><div class="line">        System.<span class="keyword">out</span>.println(inner_getName());</div><div class="line"></div><div class="line">        InnerClass inner_= <span class="keyword">out</span>.getInnerClass(, <span class="string">"chenssy"</span>);</div><div class="line">        System.<span class="keyword">out</span>.println(inner_getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="如何理解分布式锁"><a href="#如何理解分布式锁" class="headerlink" title="如何理解分布式锁"></a>如何理解分布式锁</h2><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>对共享资源的竞争过程就是并发，对共享资源数据进行访问保护的最直接方法就是引入锁</p>
<h3 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h3><ul>
<li>自旋锁（Spin Lock)<br>自旋锁如果已经被别的线程获取，调用者会一直循环看该自旋锁的持有者是否已经释放了锁<br>自旋锁是一种非阻塞锁，如果某线程需要获取自旋锁，但该锁已经被其他线程占用时，该线程不会<br>被挂起，而是不断消耗CPU时间，不停尝试获取自旋锁</li>
<li>互斥锁（Mutex Lock）<br>互斥锁是阻塞锁，当某线程无法获取互斥锁时，该线程会被直接挂起，不再消耗CPU时间，当其他线程<br>释放互斥锁时，操作系统会唤醒那个被挂起的线程<br>阻塞锁不会导致CPU占用率过高，但进入时间以及恢复时间都比自旋锁略慢，竞争激励的情况下阻塞锁的性能要明显高于自旋锁<br>Synchronized<br>ReentrantLock<br>Object.wait()/nofity()<br>LockSupport.park()/unpart()<br>多核处理器，根据预计线程等待锁时间来选择使用自旋锁或互斥锁</li>
<li>可重入锁（Reentrant Lock）<br>可重入锁是一种特殊的互斥锁，可以被同一个线程多次获取，而不会产生死锁<br>首先是互斥锁：A不释放，B无法获取<br>其次，可以被同一线程多次持有，A在释放锁之前又一次请求获取该锁，是可以成功的<br>Synchronized<br>ReentrantLock</li>
<li>轻量级锁（Lightweight Lock）&amp;偏向锁（Biased Lock）<br>java锁状态：无锁，偏向锁，轻量级锁，重量级锁；且锁状态不能降级</li>
<li>JUC(Semaphore，CountDownLatch，CyclicBarrier)<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3></li>
<li>传统方案：持久化数据库（InnoDB行锁，事务，version乐观锁）</li>
<li>新方案：zookeeper，redis等分布式组件</li>
<li>redis缓存锁：<br>setnx命令：在某个key不存在时才能set成功该key，达到多个进程并发set同一个key，只有一个可以set成功，<br>通过expire设置过期时间，性能出色，劣势一旦缓存服务宕机，锁数据就丢失了。redis虽自带复制功能，但由于复制<br>是异步完成，可能出现master节点写入锁数据未同步到slave节点时宕机，出现锁数据丢失</li>
</ul>
<h2 id="mysql两种引擎InnoDB与MyISAM对比"><a href="#mysql两种引擎InnoDB与MyISAM对比" class="headerlink" title="mysql两种引擎InnoDB与MyISAM对比"></a>mysql两种引擎InnoDB与MyISAM对比</h2><p>tips                                 MyISAM               InnoDB<br>Full Text索引                          支持                不支持<br>count（*）性能（不使用where过滤）    内置计数器，性能比较高    扫描全表，性能较差（慎用），使用where过滤，同时不使用主键进行count，性能较好<br>对事务的支持    不支持    支持事务，具有ACDI特性，同时具有四种隔离级别<br>索引结构    索引采用B+树，同时数据和索引是分离的    主键索引和数据是一起的，其他索引是和数据分离的<br>锁级别    MyISAM主要是表锁，所以性能不高    InnoDB主要是行锁，操作的粒度降低，性能比较好<br>外键支持    不支持外键    支持外键</p>
<h2 id="jvm加载一个类的过程，双亲委派模型中有哪些方法"><a href="#jvm加载一个类的过程，双亲委派模型中有哪些方法" class="headerlink" title="jvm加载一个类的过程，双亲委派模型中有哪些方法"></a>jvm加载一个类的过程，双亲委派模型中有哪些方法</h2><p>加载，验证，准备，解析，初始化<br>双亲委派模型的方法：loadClass</p>
<h3 id="jvm类加载机制："><a href="#jvm类加载机制：" class="headerlink" title="jvm类加载机制："></a>jvm类加载机制：</h3><ul>
<li>全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li>
<li>父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li>
<li>缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。<br>双亲委派机制:</li>
<li>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</li>
<li>当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</li>
<li>如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；</li>
<li>若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException</li>
</ul>
<h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><p>[<a href="http://kd.comzglb.clouddn.com/java-memory-model.png" target="_blank" rel="external">http://kd.comzglb.clouddn.com/java-memory-model.png</a>]</p>
<ul>
<li>Heap（堆内存）: 垃圾收集器管理的主要区域，GC堆，堆中没有内存完成实例分配，并且堆也无法扩展时，会抛出OutOfMemoryError异常<ul>
<li>年轻代:默认比例 1<ul>
<li>Eden</li>
<li>From Survivor</li>
<li>To Survivor</li>
</ul>
</li>
<li>老年代</li>
</ul>
</li>
<li>PermGen(方法区,永久代) : 存储类信息，常量，静态变量，即时编译器编译后的代码等，是线程共享区域，会对常量池回收和对类型的卸载，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常</li>
<li>Thread..N(栈) : java虚拟机栈和本地方法栈，用于方法的执行<ul>
<li>java栈</li>
<li>本地方法栈</li>
<li>程序计数器:唯一没有规定任何OutOfMemoryError情况的区域<br>[<a href="http://kd.comzglb.clouddn.com/jvm-area-ration.png" target="_blank" rel="external">http://kd.comzglb.clouddn.com/jvm-area-ration.png</a>]<br>控制参数：<br>-Xms设置堆的最小空间大小。<br>-Xmx设置堆的最大空间大小。<br>-XX:NewSize设置新生代最小空间大小。<br>-XX:MaxNewSize设置新生代最大空间大小。<br>-XX:PermSize设置永久代最小空间大小。<br>-XX:MaxPermSize设置永久代最大空间大小。<br>-Xss设置每个线程的堆栈大小。</li>
</ul>
</li>
</ul>
<h2 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h2><h3 id="判断对象存活"><a href="#判断对象存活" class="headerlink" title="判断对象存活"></a>判断对象存活</h3><p>引用计数<br>可达性分析 GC Roots开始向下搜索，没有在引用链上的清除<br>GC roots 一组必须活跃的引用，而非对象</p>
<ul>
<li>所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。</li>
<li>VM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。</li>
<li>JNI handles，包括global handles和local handles</li>
<li>（看情况）所有当前被加载的Java类</li>
<li>（看情况）Java类的引用类型静态变量</li>
<li>（看情况）Java类的运行时常量池里的引用类型常量（String或Class类型）</li>
<li>（看情况）String常量池（StringTable）里的引用<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3>标记-清除算法<br>标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象<br>缺点：效率不高 清除后会产生大量不连续内存碎片，会导致程序以后运行时需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作<br>复制算法<br>将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的内存用完后，就将还存活这的对象复制到另外一块，再把已使用过的内存空间一次清理掉。<br>优缺点：实现简单，运行高效，缺点是内存缩小为原来的一般，持续复制长生存期的对象则导致效率降低<br>标记-压缩算法<br>老年代特点，有人提出标记-整理算法，标记过程与标记-清除算法相同，但后续步骤是让所有存活的对象都向一端移动，然后清理掉端边界以外的内存<br>分代收集算法<br>GC分代基本假设：绝大部分对象生命周期非常短暂，存活时间短<br>Generational Collection算法，把java堆分为新生代和老年代，然后根据各个年代特点采用最适当的收集算法。新生代中，每次垃圾收集时发现有大批对象死去，就选用复制算法。老年代中，对象存活率高，没有额外空间进行分配担保，必须使用标记清除或者标记整理算法。<h3 id="垃圾收集器–垃圾收集算法的具体实现"><a href="#垃圾收集器–垃圾收集算法的具体实现" class="headerlink" title="垃圾收集器–垃圾收集算法的具体实现"></a>垃圾收集器–垃圾收集算法的具体实现</h3>Serial收集器<br>只使用一个线程去回收，新生代复制算法，老年代标记-整理，垃圾收集过程中会stop the world<br>Parallel收集器<br>新生代复制，来年代标记整理 新生代并行，老年代串行<br>Parallel Old收集器<br>使用Parallel收集器，老年代并行<br>CMS收集器<br>目的：最短回收停顿时间，初始标记，并发标记，重新标记，并发清除<br>优缺点：优点并发收集、停顿短，缺点产生大量空间碎片，并发阶段降低吞吐量<br>G集器<br>空间整合，不会产生空间碎片，可预测停顿。<br>G整个Java堆划分为多个大小相等的独立区域，新生代与老年代不再是物理隔阂了，都是一部分区域的集合<h3 id="CMS和G比较，以及G缺点，SS解决什么样的问题"><a href="#CMS和G比较，以及G缺点，SS解决什么样的问题" class="headerlink" title="CMS和G比较，以及G缺点，SS解决什么样的问题"></a>CMS和G比较，以及G缺点，SS解决什么样的问题</h3>CMS满足对相应时间的重要性需求大于对吞吐量的要求，内存中存在较多长生命周期的对象。</li>
</ul>
<p>CMS(Concurrent Mark-Sweep)是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动JVM参数加上-XX:+UseConcMarkSweepGC ，这个参数表示对于老年代的回收采用CMS。</p>
<ul>
<li>CMS回收器采用的基础算法是Mark-Sweep。所有CMS不会整理、压缩堆空间。这样就会有一个问题：经过CMS收集的堆会产生空间碎片。 CMS不对堆空间整理压缩节约了垃圾回收的停顿时间，但也带来的堆空间的浪费。为了解决堆空间浪费问题，CMS回收器不再采用简单的指针指向一块可用堆空 间来为下次对象分配使用。而是把一些未分配的空间汇总成一个列表，当JVM分配对象空间的时候，会搜索这个列表找到足够大的空间来hold住这个对象。</li>
<li>需要更多的CPU资源。从上面的图可以看到，为了让应用程序不停顿，CMS线程和应用程序线程并发执行，这样就需要有更多的CPU，单纯靠线程切 换是不靠谱的。并且，重新标记阶段，为空保证STW快速完成，也要用到更多的甚至所有的CPU资源。当然，多核多CPU也是未来的趋势！</li>
<li>CMS的另一个缺点是它需要更大的堆空间。因为CMS标记阶段应用程序的线程还是在执行的，那么就会有堆空间继续分配的情况，为了保证在CMS回 收完堆之前还有空间分配给正在运行的应用程序，必须预留一部分空间。也就是说，CMS不会在老年代满的时候才开始收集。相反，它会尝试更早的开始收集，已 避免上面提到的情况：在回收完成之前，堆没有足够空间分配！默认当老年代使用%的时候，CMS就开始行动了。</li>
</ul>
<p>G景，停顿时间可控，实时性较强，大幅度减少了长时间的GC,缺点会有一定程度的高吞吐。<br>应用程序具有如下一个或多个特征，适用于G而不是CMS<br> Full GC 次数太频繁或者消耗时间太长<br> 对象分配的频率或代数提升显式变化<br> 垃圾回收或内存整理时间较长</p>
<h2 id="线程同步与阻塞的关系，同步一定阻塞吗，阻塞一定同步吗"><a href="#线程同步与阻塞的关系，同步一定阻塞吗，阻塞一定同步吗" class="headerlink" title="线程同步与阻塞的关系，同步一定阻塞吗，阻塞一定同步吗"></a>线程同步与阻塞的关系，同步一定阻塞吗，阻塞一定同步吗</h2><p>两者没有必然关系，同步不一定阻塞，阻塞也不一定同步。</p>
<ul>
<li>同步异步<br>同步异步关注的是消息通信机制。<br>同步是发出一个调用时，没得到结果前，调用不返回，一旦返回得到返回值；异步是在调用发出后，直接返回，被调用者通过状态或通知来通知调用者或通过回调函数处理。</li>
<li>阻塞非阻塞<br>阻塞非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。<br>阻塞调用是指调用结果返回之前，当前线程会被挂起，调用线程在得到结果之后才会返回；非阻塞调用是指在不能立刻得到结果之前，该调用不会阻塞当前线程。</li>
</ul>
<h2 id="mysql的查询慢了，如何优化索引"><a href="#mysql的查询慢了，如何优化索引" class="headerlink" title="mysql的查询慢了，如何优化索引"></a>mysql的查询慢了，如何优化索引</h2><ul>
<li>开启慢查询日志，找到慢查询sql</li>
<li>通过explain查看执行计划,注意设置SQL_NO_CACHE关闭缓存</li>
<li>where条件单表查，查看字段区分度。</li>
<li>调整order by limit的顺序</li>
<li>查看索引是否符合索引建立原则：最左前缀匹配，mysql会已知向右匹配知道遇到范围查询（&gt;,&lt;,between,like)停止；= 和in可以乱序； 选择区分度高的列建立索引  索引列不能参与计算；尽量扩展索引  not in !=不会使用索引</li>
</ul>
<h2 id="Join操作时内部的原理，Join的时候大表驱动小表还是小表驱动大表，走索引的时候的复杂度是怎样的"><a href="#Join操作时内部的原理，Join的时候大表驱动小表还是小表驱动大表，走索引的时候的复杂度是怎样的" class="headerlink" title=".Join操作时内部的原理，Join的时候大表驱动小表还是小表驱动大表，走索引的时候的复杂度是怎样的"></a>.Join操作时内部的原理，Join的时候大表驱动小表还是小表驱动大表，走索引的时候的复杂度是怎样的</h2><p>应该使用小结果集驱动大结果集，join通过嵌套循环实现的，驱动结果集越大，需要虚幻次数越多。</p>
<h2 id="InnoDB的四种隔离机制，RC和RR的区别，以及在使用的时候有什么感受和问题"><a href="#InnoDB的四种隔离机制，RC和RR的区别，以及在使用的时候有什么感受和问题" class="headerlink" title=".InnoDB的四种隔离机制，RC和RR的区别，以及在使用的时候有什么感受和问题"></a>.InnoDB的四种隔离机制，RC和RR的区别，以及在使用的时候有什么感受和问题</h2><ul>
<li>第一级别 Read Uncommitted-RU   读取未提交内容</li>
<li>第二级别 Read Committed-RC     读取提交内容</li>
<li>第三级别 Repeatable Read-RR    可重复读</li>
<li>第四级别 Serializable       可串行化</li>
</ul>
<h3 id="第一级别-Read-Uncommitted（读取未提交内容）"><a href="#第一级别-Read-Uncommitted（读取未提交内容）" class="headerlink" title="第一级别 Read Uncommitted（读取未提交内容）"></a>第一级别 Read Uncommitted（读取未提交内容）</h3><p> 所有事务都可以看到其他未提交事务的执行结果<br> 本隔离级别很少实际应用，性能并不比其他级别好多少<br> 该级别引发的问题–脏读（Dirty Read）：读取到了未提交的数据</p>
<p>事务A,B:事务A开启事务，执行select，事务B开启事务，执行update；事务A在事务B执行update后即可查询到更新。</p>
<h3 id="第二级别-Read-Committed（读取提交内容）"><a href="#第二级别-Read-Committed（读取提交内容）" class="headerlink" title="第二级别 Read Committed（读取提交内容）"></a>第二级别 Read Committed（读取提交内容）</h3><p> 大多数数据库系统默认隔离级别（不是mysql默认）<br> 满足了隔离的简单定义：一个事务只能看见已经提交的事务所做的改变<br> 该级别引发问题–不可重复读（Nonrepeatable Read）：同一个事务中执行完全相同的select语句可能出现不同的结果—-&gt;原因：（有一个交叉的事务有新的commit，导致数据改变；（一个数据库被多实例操作时，同一事务的其他实例处理期间可能会有新的commit<br> 不同事务执行相同select时有可能会出现不同结果</p>
<p>事务A,B:事务A开启事务，执行select，事务B开启事务，执行update；事务A在事务B执行update后提交事务后，才可查询到更新。</p>
<h3 id="第三级别-Repeatable-Read-（可重复读）"><a href="#第三级别-Repeatable-Read-（可重复读）" class="headerlink" title="第三级别 Repeatable Read （可重复读）"></a>第三级别 Repeatable Read （可重复读）</h3><p> MySQL默认事务隔离级别<br> 确保同一事务的多个实例在并发读取数据时，看到相同的数据行<br> 该级别引发问题—幻读（Phantom Read）：当用户读取某一范围数据行时，另一个事务在该范围插入了新行，当用户再读取该范围数据行时，会发现有新的幻影行<br> InnoDB和Falcon存储引擎通过多版本并发控制（MVCC, Multiversion Concurrency Control）机制解决了该问题</p>
<p>事务A,B:事务A开启事务，执行select，事务B开启事务，执行update或insert；事务A在事务B执行update并提交后，事务A提交后方可查询到更新。</p>
<h3 id="第四级别-Serializable-（可串行化）"><a href="#第四级别-Serializable-（可串行化）" class="headerlink" title="第四级别 Serializable  （可串行化）"></a>第四级别 Serializable  （可串行化）</h3><p> 这是最高的隔离级别<br> 通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，是在每个读的数据行上加上共享锁<br> 在这个级别，可能导致大量的超时现象和锁竞争</p>
<p>事务A,B:事务A开启事务，执行select，事务B开启事务，执行update；事务B在事务A没有commit之前，是不能执行update更改数据的，只有A事务commit后，事务B方可执行update</p>
<p>脏读：读取到了未提交的数据<br>不可重复读：同一个事务中执行相同的select语句可能出现不同的结果<br>幻读：用户读取某一范围数据行时，另一个事务在该范围插入了新行，当用户再读取该范围数据行时，会发现有新的幻影行</p>
<h2 id="分布式主键生成方式有哪些中，优势和劣势是什么？SnowFlake算法具体是怎么实现的"><a href="#分布式主键生成方式有哪些中，优势和劣势是什么？SnowFlake算法具体是怎么实现的" class="headerlink" title=".分布式主键生成方式有哪些中，优势和劣势是什么？SnowFlake算法具体是怎么实现的"></a>.分布式主键生成方式有哪些中，优势和劣势是什么？SnowFlake算法具体是怎么实现的</h2><h3 id="使用数据库的auto-increment生成主键"><a href="#使用数据库的auto-increment生成主键" class="headerlink" title="使用数据库的auto_increment生成主键"></a>使用数据库的auto_increment生成主键</h3><p>优点： 简单  保证唯一 保证递增  步长固定<br>缺点：可用性难以保证，主库写存在单点故障  扩展性差，有性能上限</p>
<h3 id="单点批量ID生成服务"><a href="#单点批量ID生成服务" class="headerlink" title="单点批量ID生成服务"></a>单点批量ID生成服务</h3><p>优点：保证了ID生成的绝对递增有序 降低了数据库压力，性能高<br>缺点：服务存在单点故障  存在单点性能上限</p>
<h3 id="uuid"><a href="#uuid" class="headerlink" title="uuid"></a>uuid</h3><p>优点：本地生成ID 扩展性好<br>缺点：无法保证递增 uuid过长，索引查询效率低</p>
<h3 id="取当前毫秒数-微秒数"><a href="#取当前毫秒数-微秒数" class="headerlink" title="取当前毫秒数/微秒数"></a>取当前毫秒数/微秒数</h3><p>优点：本地生成，时延低  ID趋势递增  ID整数，索引查询效率高<br>缺点：毫秒并发超过，会生成重复ID</p>
<h3 id="SnowFlake算法-twitter开源的分布式ID生成算法"><a href="#SnowFlake算法-twitter开源的分布式ID生成算法" class="headerlink" title="SnowFlake算法 twitter开源的分布式ID生成算法"></a>SnowFlake算法 twitter开源的分布式ID生成算法</h3><p>毫秒数（bits）业务线 机房 机器(三项共位) 毫秒内序列号（共位） 拼接生成ID</p>
<h2 id="linux进程间的通信方式"><a href="#linux进程间的通信方式" class="headerlink" title=".linux进程间的通信方式"></a>.linux进程间的通信方式</h2><p>管道 信号量 信号 消息队列 共享内存 套接字 命名管道</p>
<h2 id="mysql索引失效的几种情况"><a href="#mysql索引失效的几种情况" class="headerlink" title=".mysql索引失效的几种情况"></a>.mysql索引失效的几种情况</h2><ul>
<li>条件中有or，除非or条件中每一列都加上索引</li>
<li>like查询以%开头</li>
<li>列类型是字符串，查询sql中要将数据使用引号引用起来</li>
</ul>
<h2 id="数据库范式"><a href="#数据库范式" class="headerlink" title=".数据库范式"></a>.数据库范式</h2><p>F:符合F的关系中的每个属性都不可再分<br>F:实体的属性完全依赖于主关键字。完全依赖是指不能存在仅依赖主关键字一部分的属性<br>F:任何非主属性不依赖于其他非主属性</p>
<h2 id="InnoDB主键索引与普通索引的区别和查询时的过程"><a href="#InnoDB主键索引与普通索引的区别和查询时的过程" class="headerlink" title=".InnoDB主键索引与普通索引的区别和查询时的过程"></a>.InnoDB主键索引与普通索引的区别和查询时的过程</h2><p>主键索引：加速查询+唯一值+表中只有一个+not null<br>普通索引：加速查询</p>
<h2 id="sql查询两个数据集的补集"><a href="#sql查询两个数据集的补集" class="headerlink" title=".sql查询两个数据集的补集"></a>.sql查询两个数据集的补集</h2><p>并集 union 结果集具有相同的结构 结果集列数 结果集对应的数据类型可以兼容 结果集不能包含order by和compute子句<br>差集 except 同上<br>交集 intersect 同上<br>补集 select * from a where (id) not (select id from b)</p>
<h2 id="mysql索引B-tree的原理"><a href="#mysql索引B-tree的原理" class="headerlink" title=".mysql索引B-tree的原理"></a>.mysql索引B-tree的原理</h2><h2 id="如何分库分表"><a href="#如何分库分表" class="headerlink" title=".如何分库分表"></a>.如何分库分表</h2><h3 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h3><ul>
<li>横向分表：横向切割为同样结构的不同表，表结构一样，根据特定规则来划分</li>
<li>纵向分表：多列拆分为两张表，冷热数据分离<h3 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h3></li>
<li>分库：每个库中表不同</li>
<li>分表：每个主机表相同</li>
</ul>
<h2 id="Linux下如何进行进程调度的"><a href="#Linux下如何进行进程调度的" class="headerlink" title=".Linux下如何进行进程调度的"></a>.Linux下如何进行进程调度的</h2><p>普通进程，实时进程。实时进程优先级高<br>实时进程：SCHED_FIFO 先进先出  SCHED_RR 轮转调度<br>普通进程：交互式进程 优先级较高 批处理进程 优先级较低</p>
<h2 id="redis-memcached区别，应用场景"><a href="#redis-memcached区别，应用场景" class="headerlink" title=".redis memcached区别，应用场景"></a>.redis memcached区别，应用场景</h2><ul>
<li>性能对比 redis使用单核，memcached可以使用多核，以上数据，memcached性能要高于redis</li>
<li>内存使用效率 使用简单kv存储，memcached内存利用率更高，如果redis采用hash结构来做kv存储，由于其组合式的压缩，其内存利用率高于memcached</li>
<li>redis支持服务器端的数据操作，支持复杂的结构和操作</li>
<li>memcached 多线程，非阻塞IO复用的网络模型，引入锁带来了性能损耗，redis使用单线程的IO复用模型</li>
<li>对数据持久化与数据同步有要求时，建议使用redis</li>
</ul>
<p>应用场景：</p>
<ul>
<li>redis：少量数据存储，高速读写访问，全部数据in-memory，提供数据落地功能</li>
<li>memcached：</li>
</ul>
<h2 id="如何解决Cookie盗取问题"><a href="#如何解决Cookie盗取问题" class="headerlink" title=".如何解决Cookie盗取问题"></a>.如何解决Cookie盗取问题</h2><ul>
<li>Cookie设置httponly,使得浏览器的document对象看不到cookie，不能再js中操作cookie</li>
<li>使用全站https</li>
<li>使用session或者固定时间过期的Cookie</li>
</ul>
<h2 id="线程同步工具类"><a href="#线程同步工具类" class="headerlink" title=".线程同步工具类"></a>.线程同步工具类</h2><ul>
<li>CountDownLatch–闭锁(一次性对象，进入终止状态后不能被重置)：同步工具类，可以使一个或多个线程等待一组事件发生。可以理解为一扇门，闭锁到达结束状态前门是关闭的，并且没有线程可以通过。达到结束状态时，门会打开允许所有线程通过。闭锁达到结束状态后，永远保持打开状态。可以用来确保某些活动指导其他活动都完成后才继续执行。</li>
<li>Semaphore–计数信号量：用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。还可以用来实现资源池或对容器施加边界。Semaphore中管理着一组虚拟的许可。</li>
<li>CyclicBarrier–栅栏：所有线程必须同时达到栅栏位置，才能继续执行，闭锁用于等待事件，栅栏用于等待其他线程。</li>
</ul>
<h2 id="给你三个线程，分别处理任务，再交给主线程，你如何实现。"><a href="#给你三个线程，分别处理任务，再交给主线程，你如何实现。" class="headerlink" title=".给你三个线程，分别处理任务，再交给主线程，你如何实现。"></a>.给你三个线程，分别处理任务，再交给主线程，你如何实现。</h2><ul>
<li>可以使用join方法等待</li>
<li>使用CountDownLatch</li>
</ul>
<h2 id="线程池底层实现"><a href="#线程池底层实现" class="headerlink" title=".线程池底层实现"></a>.线程池底层实现</h2><p>ExecutorService接口继承Executor接口，定义了终止，提交任务，跟踪任务返回结果等方法。</p>
<ul>
<li>execute(Runnable command)</li>
<li>submit(task) task可为Callable或Runnable</li>
<li>shutdown()</li>
<li>shutdownNow()</li>
<li>isTerminated()</li>
<li>isShutdown()<br>当创建线程池后，初始时，线程池处于RUNNING状态；<br>如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕，最后终止；<br>如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务，返回没有执行的任务列表；<br>当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态</li>
</ul>
<h2 id="servlet生命周期"><a href="#servlet生命周期" class="headerlink" title=".servlet生命周期"></a>.servlet生命周期</h2><ul>
<li>初始化阶段，调用init（）方法</li>
<li>响应客户端请求阶段，调用service（）方法</li>
<li>终止阶段，调用destroy（）方法</li>
</ul>
<h2 id="创建多线程的几种方式及区别"><a href="#创建多线程的几种方式及区别" class="headerlink" title=".创建多线程的几种方式及区别"></a>.创建多线程的几种方式及区别</h2><ul>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
<li>使用Callable接口和Future</li>
<li>线程池ExecutorService</li>
</ul>
<h2 id="wait-sleep区别"><a href="#wait-sleep区别" class="headerlink" title=".wait,sleep区别"></a>.wait,sleep区别</h2><ul>
<li>sleep睡眠时，释放CPU资源，保持对象锁，依然持有该锁</li>
<li>wait等待时，释放对象锁</li>
</ul>
<h2 id="多线程实现同步方式–阻塞-互斥-同步，非阻塞同步"><a href="#多线程实现同步方式–阻塞-互斥-同步，非阻塞同步" class="headerlink" title=".多线程实现同步方式–阻塞(互斥)同步，非阻塞同步"></a>.多线程实现同步方式–阻塞(互斥)同步，非阻塞同步</h2><p>同步和异步关注的是消息通信机制：调用者*主动等待这个调用的结果。而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果<br>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态：阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<ul>
<li>阻塞同步：就是使用synchronized等进行的同步, 因为需要进行线程的阻塞与唤醒, 而这两个操作需要进行系统调用, 进行用户态与核心态的转换, 其性能影响较大，属于悲观的枷锁策略</li>
<li>非阻塞同步：即不使用synchronized等, 不会进行线程的阻塞与唤醒. 其实现往往依赖于乐观加锁策略。</li>
</ul>
<p>出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。<br>老张把水壶放到火上，立等水开。（同步阻塞）<br>老张觉得自己有点傻<br>老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）<br>老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。<br>老张把响水壶放到火上，立等水开。（异步阻塞）<br>老张觉得这样傻等意义不大<br>老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）<br>老张觉得自己聪明了。</p>
<p>所谓同步异步，只是对于水壶而言。<br>普通水壶，同步；响水壶，异步。<br>虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。<br>同步只能让调用者去轮询自己（情况），造成老张效率的低下。</p>
<p>所谓阻塞非阻塞，仅仅对于老张而言。<br>立等的老张，阻塞；看电视的老张，非阻塞。<br>情况情况老张就是阻塞的，媳妇喊他都不知道。虽然响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。</p>
<h2 id="java新特性，做一个List到Map的转换"><a href="#java新特性，做一个List到Map的转换" class="headerlink" title=".java新特性，做一个List到Map的转换"></a>.java新特性，做一个List到Map的转换</h2><p>List<account> list<br>list.stream().collect(Collectors.toMap(Account::id,Account::number))</account></p>
<h2 id="java线程池的实现，以及溢出的时候的抛弃策略"><a href="#java线程池的实现，以及溢出的时候的抛弃策略" class="headerlink" title=".java线程池的实现，以及溢出的时候的抛弃策略"></a>.java线程池的实现，以及溢出的时候的抛弃策略</h2><p>Java线程池会将提交的任务先置于工作队列中，在从工作队列中获取(SynchronousQueue直接由生产者提交给工作线程)。那么工作队列就有两种实现策略：无界队列和有界队列。无界队列不存在饱和的问题，但是其问题是当请求持续高负载的话，任务会无脑的加入工作队列，那么很可能导致内存等资源溢出或者耗尽。而有界队列不会带来高负载导致的内存耗尽的问题，但是有引发工作队列已满情况下，新提交的任务如何管理的难题，这就是线程池工作队列饱和策略要解决的问题。<br>饱和策略分为：Abort 策略, CallerRuns 策略,Discard策略，DiscardOlds策略。</p>
<ul>
<li>Abort策略：默认策略，队列满时提交新任务抛出未检查的异常</li>
<li>CallerRuns策略：调节机制，既不抛弃任务也不抛出异常，而是将某些任务回退给调用者，会在线程池的线程中执行新的任务，而是在调用executor的线程中运行新的任务</li>
<li>Discard策略：新提交的任务被抛弃，不抛出异常</li>
<li>DiscardOldest策略：队列执行队头任务，然后尝试提交新任务，不适合工作队列为优先队列</li>
</ul>
<h2 id="针对不同场景，如何去设计线程池的大小，怎样计算线程池的大小"><a href="#针对不同场景，如何去设计线程池的大小，怎样计算线程池的大小" class="headerlink" title=".针对不同场景，如何去设计线程池的大小，怎样计算线程池的大小"></a>.针对不同场景，如何去设计线程池的大小，怎样计算线程池的大小</h2><p>如果是CPU密集型应用，则线程池大小设置为N+1<br>如果是IO密集型应用，则线程池大小设置为+1<br>最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）<em> CPU数目<br>最佳线程数目 = （线程等待时间与线程CPU时间之比 + </em> CPU数目<br>（高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+减少线程上下文的切换<br>（并发不高、任务执行时间长的业务要区分开看：<br>　　a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以适当加大线程池中的线程数目，让CPU处理更多的业务<br>　　b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换<br>（并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。</p>
<h2 id="JAVA反射机制，框架哪里设计过java的反射机制。通过反射调用一个方法，可以获取什么信息"><a href="#JAVA反射机制，框架哪里设计过java的反射机制。通过反射调用一个方法，可以获取什么信息" class="headerlink" title=".JAVA反射机制，框架哪里设计过java的反射机制。通过反射调用一个方法，可以获取什么信息"></a>.JAVA反射机制，框架哪里设计过java的反射机制。通过反射调用一个方法，可以获取什么信息</h2><p>spring ioc 加载类，<br>getDeclaredMethods可以获取类或接口声明的所有方法，包括公共，保护，默认访问和私有方法，但不包括继承的方法。<br>getMethods可以获取某个类的所有public方法，包括其继承类的公用方法。</p>
<h2 id="springmvc原理"><a href="#springmvc原理" class="headerlink" title=".springmvc原理"></a>.springmvc原理</h2><p>基于mvc的web框架<br>(.发起请求到前端控制器(DispatcherServlet);<br>(.前端控制器请求HandlerMapping查找Handler，可以根据xml配置、注解进行查找；<br>(.处理器映射器HandlerMapping向前端控制器返回Handler；<br>(.前端控制器调用处理器适配器去执行Handler；<br>(.处理器适配器去执行Handler；<br>(.Handler执行完成给适配器返回ModelAndView；<br>(.处理器适配器向前端控制器返回ModelAndView(是springmvc框架的一个底层对象，包括Model和View)；<br>(.前端控制器请求视图解析器去进行视图解析，根据逻辑视图名称解析真正的视图(jsp…)；<br>(.视图解析器向前端控制器返回View;<br>().前端控制器进行视图渲染，视图渲染就是将模型数据(在ModelAndView对象中)填充到request域中。<br>().前端控制器向用户响应结果。</p>
<h2 id="客户端发来一个请求，controller会通过单例创建一个实例处理它吗，多个线程请求会出现什么问题。"><a href="#客户端发来一个请求，controller会通过单例创建一个实例处理它吗，多个线程请求会出现什么问题。" class="headerlink" title=".客户端发来一个请求，controller会通过单例创建一个实例处理它吗，多个线程请求会出现什么问题。"></a>.客户端发来一个请求，controller会通过单例创建一个实例处理它吗，多个线程请求会出现什么问题。</h2><p><a href="https://git.coding.net/gitqh/gitqh.git" target="_blank" rel="external">https://git.coding.net/gitqh/gitqh.git</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/11/Redis_MasterSlave_Deploy/" rel="next" title="Vmware搭建Redis主从配置实验环境">
                <i class="fa fa-chevron-left"></i> Vmware搭建Redis主从配置实验环境
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/09/11/Gmail_Register/" rel="prev" title="教你注册gmail （20161019亲测有效）">
                教你注册gmail （20161019亲测有效） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Übersicht
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="qh" />
          <p class="site-author-name" itemprop="name">qh</p>
           
              <p class="site-description motion-element" itemprop="description">qh's blog | java | elasticsearch | lucene | .NET</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">Kategorien</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">Tags</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java关键字final、static使用总结"><span class="nav-number">1.</span> <span class="nav-text">Java关键字final、static使用总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#final"><span class="nav-number">1.1.</span> <span class="nav-text">final</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static"><span class="nav-number">1.2.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static-final"><span class="nav-number">1.3.</span> <span class="nav-text">static final</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#匿名内部类是什么？如何访问在其外面定义的变量。"><span class="nav-number">2.</span> <span class="nav-text">匿名内部类是什么？如何访问在其外面定义的变量。</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#匿名内部类的创建"><span class="nav-number">2.1.</span> <span class="nav-text">匿名内部类的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用场景"><span class="nav-number">2.2.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用原则"><span class="nav-number">2.3.</span> <span class="nav-text">使用原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化"><span class="nav-number">2.4.</span> <span class="nav-text">初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何理解分布式锁"><span class="nav-number">3.</span> <span class="nav-text">如何理解分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#锁"><span class="nav-number">3.1.</span> <span class="nav-text">锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁的类型"><span class="nav-number">3.2.</span> <span class="nav-text">锁的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式锁"><span class="nav-number">3.3.</span> <span class="nav-text">分布式锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mysql两种引擎InnoDB与MyISAM对比"><span class="nav-number">4.</span> <span class="nav-text">mysql两种引擎InnoDB与MyISAM对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jvm加载一个类的过程，双亲委派模型中有哪些方法"><span class="nav-number">5.</span> <span class="nav-text">jvm加载一个类的过程，双亲委派模型中有哪些方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#jvm类加载机制："><span class="nav-number">5.1.</span> <span class="nav-text">jvm类加载机制：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双亲委派模型"><span class="nav-number">5.2.</span> <span class="nav-text">双亲委派模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM内存结构"><span class="nav-number">6.</span> <span class="nav-text">JVM内存结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC算法"><span class="nav-number">7.</span> <span class="nav-text">GC算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#判断对象存活"><span class="nav-number">7.1.</span> <span class="nav-text">判断对象存活</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾收集算法"><span class="nav-number">7.2.</span> <span class="nav-text">垃圾收集算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾收集器–垃圾收集算法的具体实现"><span class="nav-number">7.3.</span> <span class="nav-text">垃圾收集器–垃圾收集算法的具体实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMS和G比较，以及G缺点，SS解决什么样的问题"><span class="nav-number">7.4.</span> <span class="nav-text">CMS和G比较，以及G缺点，SS解决什么样的问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程同步与阻塞的关系，同步一定阻塞吗，阻塞一定同步吗"><span class="nav-number">8.</span> <span class="nav-text">线程同步与阻塞的关系，同步一定阻塞吗，阻塞一定同步吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mysql的查询慢了，如何优化索引"><span class="nav-number">9.</span> <span class="nav-text">mysql的查询慢了，如何优化索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Join操作时内部的原理，Join的时候大表驱动小表还是小表驱动大表，走索引的时候的复杂度是怎样的"><span class="nav-number">10.</span> <span class="nav-text">.Join操作时内部的原理，Join的时候大表驱动小表还是小表驱动大表，走索引的时候的复杂度是怎样的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB的四种隔离机制，RC和RR的区别，以及在使用的时候有什么感受和问题"><span class="nav-number">11.</span> <span class="nav-text">.InnoDB的四种隔离机制，RC和RR的区别，以及在使用的时候有什么感受和问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一级别-Read-Uncommitted（读取未提交内容）"><span class="nav-number">11.1.</span> <span class="nav-text">第一级别 Read Uncommitted（读取未提交内容）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二级别-Read-Committed（读取提交内容）"><span class="nav-number">11.2.</span> <span class="nav-text">第二级别 Read Committed（读取提交内容）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第三级别-Repeatable-Read-（可重复读）"><span class="nav-number">11.3.</span> <span class="nav-text">第三级别 Repeatable Read （可重复读）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第四级别-Serializable-（可串行化）"><span class="nav-number">11.4.</span> <span class="nav-text">第四级别 Serializable  （可串行化）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式主键生成方式有哪些中，优势和劣势是什么？SnowFlake算法具体是怎么实现的"><span class="nav-number">12.</span> <span class="nav-text">.分布式主键生成方式有哪些中，优势和劣势是什么？SnowFlake算法具体是怎么实现的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用数据库的auto-increment生成主键"><span class="nav-number">12.1.</span> <span class="nav-text">使用数据库的auto_increment生成主键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单点批量ID生成服务"><span class="nav-number">12.2.</span> <span class="nav-text">单点批量ID生成服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#uuid"><span class="nav-number">12.3.</span> <span class="nav-text">uuid</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#取当前毫秒数-微秒数"><span class="nav-number">12.4.</span> <span class="nav-text">取当前毫秒数/微秒数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SnowFlake算法-twitter开源的分布式ID生成算法"><span class="nav-number">12.5.</span> <span class="nav-text">SnowFlake算法 twitter开源的分布式ID生成算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux进程间的通信方式"><span class="nav-number">13.</span> <span class="nav-text">.linux进程间的通信方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mysql索引失效的几种情况"><span class="nav-number">14.</span> <span class="nav-text">.mysql索引失效的几种情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库范式"><span class="nav-number">15.</span> <span class="nav-text">.数据库范式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB主键索引与普通索引的区别和查询时的过程"><span class="nav-number">16.</span> <span class="nav-text">.InnoDB主键索引与普通索引的区别和查询时的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sql查询两个数据集的补集"><span class="nav-number">17.</span> <span class="nav-text">.sql查询两个数据集的补集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mysql索引B-tree的原理"><span class="nav-number">18.</span> <span class="nav-text">.mysql索引B-tree的原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何分库分表"><span class="nav-number">19.</span> <span class="nav-text">.如何分库分表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分表"><span class="nav-number">19.1.</span> <span class="nav-text">分表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分库"><span class="nav-number">19.2.</span> <span class="nav-text">分库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux下如何进行进程调度的"><span class="nav-number">20.</span> <span class="nav-text">.Linux下如何进行进程调度的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis-memcached区别，应用场景"><span class="nav-number">21.</span> <span class="nav-text">.redis memcached区别，应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何解决Cookie盗取问题"><span class="nav-number">22.</span> <span class="nav-text">.如何解决Cookie盗取问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程同步工具类"><span class="nav-number">23.</span> <span class="nav-text">.线程同步工具类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#给你三个线程，分别处理任务，再交给主线程，你如何实现。"><span class="nav-number">24.</span> <span class="nav-text">.给你三个线程，分别处理任务，再交给主线程，你如何实现。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池底层实现"><span class="nav-number">25.</span> <span class="nav-text">.线程池底层实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#servlet生命周期"><span class="nav-number">26.</span> <span class="nav-text">.servlet生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建多线程的几种方式及区别"><span class="nav-number">27.</span> <span class="nav-text">.创建多线程的几种方式及区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wait-sleep区别"><span class="nav-number">28.</span> <span class="nav-text">.wait,sleep区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程实现同步方式–阻塞-互斥-同步，非阻塞同步"><span class="nav-number">29.</span> <span class="nav-text">.多线程实现同步方式–阻塞(互斥)同步，非阻塞同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java新特性，做一个List到Map的转换"><span class="nav-number">30.</span> <span class="nav-text">.java新特性，做一个List到Map的转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java线程池的实现，以及溢出的时候的抛弃策略"><span class="nav-number">31.</span> <span class="nav-text">.java线程池的实现，以及溢出的时候的抛弃策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#针对不同场景，如何去设计线程池的大小，怎样计算线程池的大小"><span class="nav-number">32.</span> <span class="nav-text">.针对不同场景，如何去设计线程池的大小，怎样计算线程池的大小</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JAVA反射机制，框架哪里设计过java的反射机制。通过反射调用一个方法，可以获取什么信息"><span class="nav-number">33.</span> <span class="nav-text">.JAVA反射机制，框架哪里设计过java的反射机制。通过反射调用一个方法，可以获取什么信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#springmvc原理"><span class="nav-number">34.</span> <span class="nav-text">.springmvc原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#客户端发来一个请求，controller会通过单例创建一个实例处理它吗，多个线程请求会出现什么问题。"><span class="nav-number">35.</span> <span class="nav-text">.客户端发来一个请求，controller会通过单例创建一个实例处理它吗，多个线程请求会出现什么问题。</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qh</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
