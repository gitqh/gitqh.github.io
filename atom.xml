<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>qh&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/d78a9311ff151a0843c2d843bfdc09af</icon>
  <subtitle>think twice before action</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gitqh.github.io/"/>
  <updated>2015-07-28T14:30:56.000Z</updated>
  <id>http://gitqh.github.io/</id>
  
  <author>
    <name>qh</name>
    <email>quhang19881208@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker 入门篇</title>
    <link href="http://gitqh.github.io/2017/09/11/Docker_basic/"/>
    <id>http://gitqh.github.io/2017/09/11/Docker_basic/</id>
    <published>2017-09-11T07:17:34.000Z</published>
    <updated>2015-07-28T14:30:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>Docker是2014年较为热门的技术，本文作为一篇入门教程，通过以下四个问题的解答，希望能够使读者对Docker有一些认识。</p><hr><h2 id="1-Docker是什么？"><a href="#1-Docker是什么？" class="headerlink" title="1.Docker是什么？"></a>1.Docker是什么？</h2><ul><li><p><strong>Docker</strong>是2013年dotCloud公司的一个业余项目，采用<strong>go</strong>语言实现，在github进行维护。</p></li><li><p>项目的目标是<strong>实现轻量级的操作系统虚拟化解决方案</strong>，Docker的基础是<strong>Linux容器</strong>等技术，目前只能在linux平台工作。</p></li><li><p>目前，微软与Docker公司建立了新的合作伙伴关系，以便在Windows Server上增加对Docker工具的支持，微软开发技术公司将向Docker客户端贡献代码。</p></li></ul><hr><a id="more"></a><h2 id="2-Docker与传统虚拟化解决方案相比，优势在哪里？"><a href="#2-Docker与传统虚拟化解决方案相比，优势在哪里？" class="headerlink" title="2.Docker与传统虚拟化解决方案相比，优势在哪里？"></a>2.Docker与传统虚拟化解决方案相比，优势在哪里？</h2><p>Docker通过容器在操作系统层面实现虚拟化，传统方式则是在硬件层面通过虚拟机形式实现。</p><hr><h2 id="3-Docker解决了哪些实际问题？"><a href="#3-Docker解决了哪些实际问题？" class="headerlink" title="3.Docker解决了哪些实际问题？"></a>3.Docker解决了哪些实际问题？</h2><ul><li>更快速的交付和部署</li></ul><p>对开发和运维（devop）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。开发者可以使用一个标准的镜像来构建一套开发容器，开发完成之后，运维人员可以直接使用这个容器来部署代码。 Docker可以快速创建容器，快速迭代应用程序，并让整个过程全程可见，使团队中的其他成员更容易理解应用程序是如何创建和工作的。Docker容器的启动时间是秒级的，大量地节约开发、测试、部署的时间。</p><ul><li>更高效的虚拟化</li></ul><p>Docker容器运行不需要hypervisor支持，它是内核级的虚拟化，有更高的性能和效率。</p><p>Hypervisor是一种运行在物理服务器和操作系统之间的中间软件层,可允许多个操作系统和应用共享一套基础物理硬件，因此也可以看作是虚拟环境中的“元”操作系统，它可以协调访问服务器上的所有物理设备和虚拟机，也叫虚拟机监视器（Virtual Machine Monitor）</p><ul><li>更轻松的迁移与扩展</li></ul><p>Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。 这种兼容性可以让用户把一个应用程序从一个平台直接迁移到另外一个。</p><ul><li>更简单的管理</li></ul><p>使用Docker，所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理。</p><hr><h2 id="4-Docker引入了哪些技术？"><a href="#4-Docker引入了哪些技术？" class="headerlink" title="4.Docker引入了哪些技术？"></a>4.Docker引入了哪些技术？</h2><ul><li>镜像</li></ul><p>Docker 镜像就是一个只读的模板。例如：一个镜像可以包含一个完整的ubuntu操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。</p><p>镜像可以用来创建 Docker 容器。Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户也可以从仓库下载已经做好的镜像来直接使用。</p><ul><li>容器</li></ul><p>Docker 利用容器来运行应用。容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。</p><p>可以把容器看做是一个简易版的Linux环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p><ul><li>仓库</li></ul><p>与github仓库的托管服务类似，docker hub，dockerpoo是目前比较常用的公开仓库，用户可以实现上传或下载。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker是2014年较为热门的技术，本文作为一篇入门教程，通过以下四个问题的解答，希望能够使读者对Docker有一些认识。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;1-Docker是什么？&quot;&gt;&lt;a href=&quot;#1-Docker是什么？&quot; class=&quot;headerlink&quot; title=&quot;1.Docker是什么？&quot;&gt;&lt;/a&gt;1.Docker是什么？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Docker&lt;/strong&gt;是2013年dotCloud公司的一个业余项目，采用&lt;strong&gt;go&lt;/strong&gt;语言实现，在github进行维护。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;项目的目标是&lt;strong&gt;实现轻量级的操作系统虚拟化解决方案&lt;/strong&gt;，Docker的基础是&lt;strong&gt;Linux容器&lt;/strong&gt;等技术，目前只能在linux平台工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;目前，微软与Docker公司建立了新的合作伙伴关系，以便在Windows Server上增加对Docker工具的支持，微软开发技术公司将向Docker客户端贡献代码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Virtualization" scheme="http://gitqh.github.io/categories/Virtualization/"/>
    
    
  </entry>
  
  <entry>
    <title>教你注册gmail （20161019亲测有效）</title>
    <link href="http://gitqh.github.io/2017/09/11/Gmail_Register/"/>
    <id>http://gitqh.github.io/2017/09/11/Gmail_Register/</id>
    <published>2017-09-11T07:17:34.000Z</published>
    <updated>2016-10-19T05:57:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>在注册gmail验证手机号码的时候，大家经常遇到提示“此号码不能用于验证”的问题，上午摸索出一个可行的方法，分享给大家。</p><hr><a id="more"></a><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li><p>chrome浏览器升级到最新版</p></li><li><p>有自由翻墙的VPN</p></li></ul><hr><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><p>连接VPN</p></li><li><p>打开chrome 设置-&gt;登录-&gt;登录chrome （这一步最为关键）</p></li><li><p>填入要注册的gmail账户</p></li><li><p>验证手机号，选择中国，即可收到短信</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在注册gmail验证手机号码的时候，大家经常遇到提示“此号码不能用于验证”的问题，上午摸索出一个可行的方法，分享给大家。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="skill" scheme="http://gitqh.github.io/categories/skill/"/>
    
    
      <category term="soft skill" scheme="http://gitqh.github.io/tags/soft-skill/"/>
    
  </entry>
  
  <entry>
    <title>Vmware搭建Redis主从配置实验环境</title>
    <link href="http://gitqh.github.io/2017/09/11/Redis_MasterSlave_Deploy/"/>
    <id>http://gitqh.github.io/2017/09/11/Redis_MasterSlave_Deploy/</id>
    <published>2017-09-11T07:17:34.000Z</published>
    <updated>2015-08-08T08:22:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Redis </strong>（REmote DIctionary Server）是一个类似于Memcached的Key-Value存储系统。相比Memcached，它支持更丰富的数据结构，包括<strong>string</strong>(字符串)、<strong>list</strong>(链表)、<strong>set</strong>(集合)、<strong>zset</strong>(sorted set：有序集合)和<strong>hash</strong>（哈希类型），并提供了数据持久化机制，在某些场景下，你完全可以把它当做非关系型数据库来使用。它是一个高性能的存储系统，能支持每秒15万以上的读写速率。</p><p>本文记录了自己在vmware虚拟机中搭建Redis主从集群的经验，希望能为想深入学习Redis的朋友提供一些帮助。</p><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a><a name="catalog">目录</a></h2><p><a href="#chart1">1.  部署环境说明 </a></p><p><a href="#chart2">2.  Vmware准备 </a></p><p><a href="#chart3">3.  Redis下载 </a></p><p><a href="#chart4">4.  Redis编译安装 </a></p><p><a href="#chart5">5.  克隆搭建从服务器 </a></p><p><a href="#chart6">6.  Redis配置 </a></p><p><a href="#chart7">7.  Redis服务启动 </a></p><p><a href="#chart8">8.  Redis测试 </a></p><hr><a id="more"></a><h2 id="1-安装环境说明"><a href="#1-安装环境说明" class="headerlink" title="1.安装环境说明"></a><a name="chart1">1.安装环境说明</a></h2><p>目的：搭建一主两从的Redis集群环境</p><p>版本说明：</p><ul><li><p><code>Vmware：11.1.2</code></p></li><li><p><code>CentOS：6.5</code></p></li><li><p><code>Redis：3.0.3</code></p></li></ul><p><a href="#catalog"><p style="text-align: right">回到目录</p></a></p><hr><h2 id="2-Vmware准备"><a href="#2-Vmware准备" class="headerlink" title="2. Vmware准备"></a><a name="chart2">2. Vmware准备</a></h2><ul><li><p>使用Vmware新建一台虚拟机，安装CentOS6.5（或者克隆之前安装过的某台虚拟机），作为Redis主Server</p></li><li><p>修改主Server的网络配置，Vmware克隆的虚拟机会出现无法找到eth0网卡的问题</p><ul><li><p>原因：很多Linux distribution使用udev动态管理设备文件，并根据设备的信息对其进行持久化命名。例如在 Debian etch中，udev会在系统引导的过程中识别网卡，将mac地址和网卡名称对应起来记录在udev的规则脚本中。而VMware会自动生成虚拟机的mac地址。这样，由于基本系统的虚拟机已经记录了该虚拟机的网卡mac地址对应于网卡eth0，在克隆出的虚拟机中由于mac地址发生改变，udev会自动将该mac对应于网卡eth1。以此类推，udev会记录所有已经识别的mac与网卡名的关系，所以每次克隆网卡名称会自动加1，而其实kernel仅仅只识别到一张网卡，跟网卡名相关的网络配置也未发生任何变化。</p></li><li><p>解决方法：</p><ul><li><p>执行命令<code>vi /etc/udev/rules.d/70-persistent-net.rules</code>，删除跟NAME=”eth0″相关的行，将eth1相关信息中的eth1替换为eth0</p></li><li><p>接着执行命令<code>reboot</code>,重启系统：</p></li></ul></li></ul></li><li><p>关闭防火墙</p></li></ul><p>切换至命令行界面，执行<code>Service iptables stop</code>（注意：该方法重启后失效）</p><ul><li>查看主机IP</li></ul><p>执行命令<code>ifconfig</code>，记录主机的局域网IP，本机测试IP为192.168.1.102</p><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/Rdies_MasterSlave_deploy_2015-08-02_16-11-30.png" alt=""></p><p><a href="#catalog"><p style="text-align: right">回到目录</p></a></p><hr><h2 id="3-Redis下载"><a href="#3-Redis下载" class="headerlink" title="3. Redis下载"></a><a name="chart3">3. Redis下载</a></h2><p>Redis的下载地址：<a href="http://redis.io/download" target="_blank" rel="noopener">http://redis.io/download</a>，建议下载Stable稳定版<strong>redis-3.0.3.tar.gz</strong></p><p>下载后可使用Vmware Tools或者Xftp等工具发送到虚拟机中</p><p><a href="#catalog"><p style="text-align: right">回到目录</p></a></p><hr><h2 id="4-Redis编译安装"><a href="#4-Redis编译安装" class="headerlink" title="4. Redis编译安装"></a><a name="chart4">4. Redis编译安装</a></h2><ul><li>解压缩：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">tar xzvf redis-2.0.0-rc4.tar.gz</span><br></pre></td></tr></table></figure><ul><li>编译：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">make</span><br></pre></td></tr></table></figure><ul><li>安装：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ./src</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>  安装完成后，会在src目录下生成可执行文件，分别是redis-server、redis-cli、redis-benchmark、redis-stat，它们的作用如下：</p><blockquote><ul><li>redis-server：Redis服务器的daemon启动程序</li><li>redis-cli：Redis命令行操作工具。当然，你也可以用telnet根据其纯文本协议来操作</li><li>redis-benchmark：Redis性能测试工具，测试Redis在你的系统及你的配置下的读写性能</li><li>redis-stat：Redis状态检测工具，可以检测Redis当前状态参数及延迟状况</li></ul></blockquote><ul><li>拷贝：</li></ul><p>为了便于管理，我们建立如下目录<code>/home/redis/bin</code>与<code>/home/redis/etc</code>，将可执行文件及配置文件redis.conf分别拷贝至bin与etc目录下</p><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/Rdies_MasterSlave_deploy_2015-08-02_16-27-10.png" alt=""></p><p><a href="#catalog"><p style="text-align: right">回到目录</p></a></p><hr><h2 id="5-克隆搭建从服务器"><a href="#5-克隆搭建从服务器" class="headerlink" title="5. 克隆搭建从服务器"></a><a name="chart5">5. 克隆搭建从服务器</a></h2><p>将主Server关机后，克隆两台从Server，修改网络配置并关闭防火墙。</p><p><a href="#catalog"><p style="text-align: right">回到目录</p></a></p><hr><h2 id="6-优化系统配置"><a href="#6-优化系统配置" class="headerlink" title="6. 优化系统配置"></a><a name="chart6">6. 优化系统配置</a></h2><p>查看系统配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>添加<code>vm.overcommit_memory=1</code></p><p>刷新配置使之生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl vm.overcommit_memory=1</span><br></pre></td></tr></table></figure><p>补充介绍：</p><ul><li>如果内存情况比较紧张的话，需要设定内核参数：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/vm/overcommit_memory</span><br></pre></td></tr></table></figure><ul><li><p>内核参数说明如下：</p><p><code>&gt;overcommit_memory</code>文件指定了内核针对内存分配的策略，其值可以是0、1、2。</p><ul><li><p>0， 表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。</p></li><li><p>1， 表示内核允许分配所有的物理内存，而不管当前的内存状态如何。</p></li><li><p>2， 表示内核允许分配超过所有物理内存和交换空间总和的内存</p></li></ul></li></ul><hr><h2 id="7-Redis配置"><a href="#7-Redis配置" class="headerlink" title="7. Redis配置"></a><a name="chart7">7. Redis配置</a></h2><p>编辑<code>redis.conf</code>配置文件（/etc/redis.conf），按需求做出适当调整，主要参数意义如下所示：</p><blockquote><ul><li><code>daemonize：是否以后台daemon方式运行</code></li><li><code>pidfile：pid文件位置</code></li><li><code>port：监听的端口号</code></li><li><code>timeout：请求超时时间</code></li><li><code>loglevel：log信息级别</code></li><li><code>logfile：log文件位置</code></li><li><code>databases：开启数据库的数量</code></li><li><code>save X X：保存快照的频率，第一个X表示多长时间，第二个X表示执行多少次写操作。在一定时间内执行一定数量的写操作时，自动保存快照。可设置多个条件。</code></li><li><code>rdbcompression：是否使用压缩</code></li><li><code>dbfilename：数据快照文件名（只是文件名，不包括目录）</code></li><li><code>dir：数据快照的保存目录（这个是目录）</code></li><li><code>appendonly：是否开启appendonlylog，开启的话每次写操作会记一条log，这会提高数据抗风险能力，但影响效率。</code></li><li><code>appendfsync：appendonlylog如何同步到磁盘（三个选项，分别是每次写都强制调用fsync、每秒启用一次fsync、不调用fsync等待系统自己同步）</code></li><li><code>masterauth：主Server的密码</code></li></ul></blockquote><p>此处修改主服务器的选项为后台启动，密码为123456`</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">requirepass 123456</span><br></pre></td></tr></table></figure><p>修改从服务器的选项为后台启动，slaveof填写主机IP，端口默认为6379，密码为123456</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">slaveof 192.168.1.102 6379</span><br><span class="line">masterauth 123456</span><br></pre></td></tr></table></figure><p><a href="#catalog"><p style="text-align: right">回到目录</p></a></p><hr><h2 id="7-Redis服务启动"><a href="#7-Redis服务启动" class="headerlink" title="7. Redis服务启动"></a><a name="chart7">7. Redis服务启动</a></h2><p>在一主两从三台虚拟机上分别执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/redis/bin/redis-server /home/redis/etc/redis.conf</span><br></pre></td></tr></table></figure><p>可通过命令查看是否正常启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#检测后台进程是否存在</span></span><br><span class="line">ps -ef |grep redis</span><br><span class="line"><span class="comment">#检测6379端口是否在监听</span></span><br><span class="line">netstat -lntp | grep 6379</span><br></pre></td></tr></table></figure><p><a href="#catalog"><p style="text-align: right">回到目录</p></a></p><hr><h2 id="8-Redis测试"><a href="#8-Redis测试" class="headerlink" title="8. Redis测试"></a><a name="chart8">8. Redis测试</a></h2><p>执行命令启动redis命令行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/redis/bin/redis-cli</span><br></pre></td></tr></table></figure><p>在主Server上执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> name jack</span><br></pre></td></tr></table></figure><p>然后在从Server上执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get name</span><br></pre></td></tr></table></figure><p>如能正确返回name值则说明主从环境搭建成功</p><p><a href="#catalog"><p style="text-align: right">回到目录</p></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Redis &lt;/strong&gt;（REmote DIctionary Server）是一个类似于Memcached的Key-Value存储系统。相比Memcached，它支持更丰富的数据结构，包括&lt;strong&gt;string&lt;/strong&gt;(字符串)、&lt;strong&gt;list&lt;/strong&gt;(链表)、&lt;strong&gt;set&lt;/strong&gt;(集合)、&lt;strong&gt;zset&lt;/strong&gt;(sorted set：有序集合)和&lt;strong&gt;hash&lt;/strong&gt;（哈希类型），并提供了数据持久化机制，在某些场景下，你完全可以把它当做非关系型数据库来使用。它是一个高性能的存储系统，能支持每秒15万以上的读写速率。&lt;/p&gt;
&lt;p&gt;本文记录了自己在vmware虚拟机中搭建Redis主从集群的经验，希望能为想深入学习Redis的朋友提供一些帮助。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;&lt;a name=&quot;catalog&quot;&gt;目录&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;#chart1&quot;&gt;1.  部署环境说明 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#chart2&quot;&gt;2.  Vmware准备 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#chart3&quot;&gt;3.  Redis下载 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#chart4&quot;&gt;4.  Redis编译安装 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#chart5&quot;&gt;5.  克隆搭建从服务器 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#chart6&quot;&gt;6.  Redis配置 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#chart7&quot;&gt;7.  Redis服务启动 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#chart8&quot;&gt;8.  Redis测试 &lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://gitqh.github.io/categories/Redis/"/>
    
    
      <category term="Redis Master—Slave" scheme="http://gitqh.github.io/tags/Redis-Master%E2%80%94Slave/"/>
    
  </entry>
  
  <entry>
    <title>Java面试题</title>
    <link href="http://gitqh.github.io/2017/09/11/Java_Interview/"/>
    <id>http://gitqh.github.io/2017/09/11/Java_Interview/</id>
    <published>2017-09-11T07:17:34.000Z</published>
    <updated>2017-10-08T07:39:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>收集的Java经典面试题</p><hr><a id="more"></a><h2 id="Java关键字final、static使用总结"><a href="#Java关键字final、static使用总结" class="headerlink" title="Java关键字final、static使用总结"></a>Java关键字final、static使用总结</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ul><li>final：终态，可以修饰非抽象类、非抽象类成员方法和变量</li><li>final类：不能被继承，没有子类，final类中的方法默认是final的。如果一个类不需要有子类，且类的实现细节不允许改变，并且这个<br>类不会被扩展，可以设计为final类</li><li>final方法：不能被子类的方法覆盖，可以被继承。final方法使用原因：锁定方法，防止继承类修改；高效，编译器遇到final方法会转入内嵌机制，提高执行效率</li><li>final成员变量：常量，只能被赋值一次，赋值后值不再改变</li><li>final参数：可以读取该参数，但无法改变该参数的值</li><li>注意：final不能用于修饰构造方法，private类型的方法默认是final类型的<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3></li><li>static：全局或静态</li><li>static：成员变量与成员方法：被类所有实例共享，静态变量在内存中只有一个拷贝，节省内存</li><li>static方法：静态方法，方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法</li><li>static代码块：JVM加载类时会执行，多处代码块会按照在类中出现的先后顺序依次执行<h3 id="static-final"><a href="#static-final" class="headerlink" title="static final"></a>static final</h3></li><li>static final变量：全局常量</li><li>static final方法：方法不可覆盖</li></ul><h2 id="匿名内部类是什么？如何访问在其外面定义的变量。"><a href="#匿名内部类是什么？如何访问在其外面定义的变量。" class="headerlink" title="匿名内部类是什么？如何访问在其外面定义的变量。"></a>匿名内部类是什么？如何访问在其外面定义的变量。</h2><p>访问在其外面的变量，必须通过关键字final作为形参传入<br>拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，所以用final来让该引用不可改变</p><h3 id="匿名内部类的创建"><a href="#匿名内部类的创建" class="headerlink" title="匿名内部类的创建"></a>匿名内部类的创建</h3><p>new 父类构造器（参数列表）|实现接口（）<br>    {<br>     //匿名内部类的类体部分<br>    }</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>只用到类的一个实例</li><li>类在定义后马上用到</li><li>类非常小（sun推荐代码一下）</li><li>给类命名并不会导致代码更容易被理解<h3 id="使用原则"><a href="#使用原则" class="headerlink" title="使用原则"></a>使用原则</h3></li><li>不能有构造方法</li><li>不能定义静态成员、方法和类</li><li>匿名内部类不能是public，protected，private，static</li><li>只能创建一个实例</li><li>一个匿名内部类一定在new后面，用其隐含实现一个接口或一个类</li><li>匿名内部类为局部内部类，所以局部内部类的所有限制都对其生效<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3>通过代码块完成初始化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class OutClass &#123;</span><br><span class="line">    public InnerClass getInnerClass(final int age, final String name)&#123;</span><br><span class="line">        return new InnerClass() &#123;</span><br><span class="line">            int age_ ;</span><br><span class="line">            String name_;</span><br><span class="line">            //构造代码块完成初始化工作</span><br><span class="line">            &#123;</span><br><span class="line">                if( 18 &lt; age &amp;&amp; age &lt; 36) &#123;</span><br><span class="line">                    age_ = age;</span><br><span class="line">                    name_ = name;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            public String getName() &#123;</span><br><span class="line">                return name_;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public int getAge() &#123;</span><br><span class="line">                return age_;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        OutClass out = new OutClass();</span><br><span class="line">        InnerClass inner_= out.getInnerClass( &quot;chenssy&quot;);</span><br><span class="line">        System.out.println(inner_.getName());</span><br><span class="line"></span><br><span class="line">        InnerClass inner_= out.getInnerClass( &quot;chenssy&quot;);</span><br><span class="line">        System.out.println(inner_.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="如何理解分布式锁"><a href="#如何理解分布式锁" class="headerlink" title="如何理解分布式锁"></a>如何理解分布式锁</h2><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>对共享资源的竞争过程就是并发，对共享资源数据进行访问保护的最直接方法就是引入锁</p><h3 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h3><ul><li>自旋锁（Spin Lock)<br>自旋锁如果已经被别的线程获取，调用者会一直循环看该自旋锁的持有者是否已经释放了锁<br>自旋锁是一种非阻塞锁，如果某线程需要获取自旋锁，但该锁已经被其他线程占用时，该线程不会<br>被挂起，而是不断消耗CPU时间，不停尝试获取自旋锁</li><li>互斥锁（Mutex Lock）<br>互斥锁是阻塞锁，当某线程无法获取互斥锁时，该线程会被直接挂起，不再消耗CPU时间，当其他线程<br>释放互斥锁时，操作系统会唤醒那个被挂起的线程<br>阻塞锁不会导致CPU占用率过高，但进入时间以及恢复时间都比自旋锁略慢，竞争激励的情况下阻塞锁的性能要明显高于自旋锁<br>Synchronized<br>ReentrantLock<br>Object.wait()/nofity()<br>LockSupport.park()/unpark()<br>多核处理器，根据预计线程等待锁时间来选择使用自旋锁或互斥锁</li><li>可重入锁（Reentrant Lock）<br>可重入锁是一种特殊的互斥锁，可以被同一个线程多次获取，而不会产生死锁<br>首先是互斥锁：A不释放，B无法获取<br>其次，可以被同一线程多次持有，A在释放锁之前又一次请求获取该锁，是可以成功的<br>Synchronized<br>ReentrantLock</li><li>轻量级锁（Lightweight Lock）&amp;偏向锁（Biased Lock）<br>java锁状态：无锁，偏向锁，轻量级锁，重量级锁；且锁状态不能降级</li><li>JUC(Semaphore，CountDownLatch，CyclicBarrier)<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3></li><li>传统方案：持久化数据库（InnoDB行锁，事务，version乐观锁）</li><li>新方案：zookeeper，redis等分布式组件</li><li>redis缓存锁：<br>setnx命令：在某个key不存在时才能set成功该key，达到多个进程并发set同一个key，只有一个可以set成功，<br>通过expire设置过期时间，性能出色，劣势一旦缓存服务宕机，锁数据就丢失了。redis虽自带复制功能，但由于复制<br>是异步完成，可能出现master节点写入锁数据未同步到slave节点时宕机，出现锁数据丢失</li></ul><h2 id="mysql两种引擎InnoDB与MyISAM对比"><a href="#mysql两种引擎InnoDB与MyISAM对比" class="headerlink" title="mysql两种引擎InnoDB与MyISAM对比"></a>mysql两种引擎InnoDB与MyISAM对比</h2><p>tips                                 MyISAM               InnoDB<br>Full Text索引                          支持                不支持<br>count（*）性能（不使用where过滤）    内置计数器，性能比较高    扫描全表，性能较差（慎用），使用where过滤，同时不使用主键进行count，性能较好<br>对事务的支持    不支持    支持事务，具有ACDI特性，同时具有四种隔离级别<br>索引结构    索引采用B+树，同时数据和索引是分离的    主键索引和数据是一起的，其他索引是和数据分离的<br>锁级别    MyISAM主要是表锁，所以性能不高    InnoDB主要是行锁，操作的粒度降低，性能比较好<br>外键支持    不支持外键    支持外键</p><h2 id="jvm加载一个类的过程，双亲委派模型中有哪些方法"><a href="#jvm加载一个类的过程，双亲委派模型中有哪些方法" class="headerlink" title="jvm加载一个类的过程，双亲委派模型中有哪些方法"></a>jvm加载一个类的过程，双亲委派模型中有哪些方法</h2><p>加载，验证，准备，解析，初始化<br>双亲委派模型的方法：loadClass</p><h3 id="jvm类加载机制："><a href="#jvm类加载机制：" class="headerlink" title="jvm类加载机制："></a>jvm类加载机制：</h3><ul><li>全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li><li>父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li><li>缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。<br>双亲委派机制:</li><li>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</li><li>当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</li><li>如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；</li><li>若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException</li></ul><h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><p>[<a href="http://kd.comzglb.clouddn.com/java-memory-model.png]" target="_blank" rel="noopener">http://kd.comzglb.clouddn.com/java-memory-model.png]</a></p><ul><li>Heap（堆内存）: 垃圾收集器管理的主要区域，GC堆，堆中没有内存完成实例分配，并且堆也无法扩展时，会抛出OutOfMemoryError异常<ul><li>年轻代:默认比例 1<ul><li>Eden</li><li>From Survivor</li><li>To Survivor</li></ul></li><li>老年代</li></ul></li><li>PermGen(方法区,永久代) : 存储类信息，常量，静态变量，即时编译器编译后的代码等，是线程共享区域，会对常量池回收和对类型的卸载，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常</li><li>Thread..N(栈) : java虚拟机栈和本地方法栈，用于方法的执行<ul><li>java栈</li><li>本地方法栈</li><li>程序计数器:唯一没有规定任何OutOfMemoryError情况的区域<br>[<a href="http://kd.comzglb.clouddn.com/jvm-area-ration.png]" target="_blank" rel="noopener">http://kd.comzglb.clouddn.com/jvm-area-ration.png]</a><br>控制参数：<br>-Xms设置堆的最小空间大小。<br>-Xmx设置堆的最大空间大小。<br>-XX:NewSize设置新生代最小空间大小。<br>-XX:MaxNewSize设置新生代最大空间大小。<br>-XX:PermSize设置永久代最小空间大小。<br>-XX:MaxPermSize设置永久代最大空间大小。<br>-Xss设置每个线程的堆栈大小。</li></ul></li></ul><h2 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h2><h3 id="判断对象存活"><a href="#判断对象存活" class="headerlink" title="判断对象存活"></a>判断对象存活</h3><p>引用计数<br>可达性分析 GC Roots开始向下搜索，没有在引用链上的清除<br>GC roots 一组必须活跃的引用，而非对象</p><ul><li>所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。</li><li>VM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。</li><li>JNI handles，包括global handles和local handles</li><li>（看情况）所有当前被加载的Java类</li><li>（看情况）Java类的引用类型静态变量</li><li>（看情况）Java类的运行时常量池里的引用类型常量（String或Class类型）</li><li>（看情况）String常量池（StringTable）里的引用<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3>标记-清除算法<br>标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象<br>缺点：效率不高 清除后会产生大量不连续内存碎片，会导致程序以后运行时需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作<br>复制算法<br>将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的内存用完后，就将还存活这的对象复制到另外一块，再把已使用过的内存空间一次清理掉。<br>优缺点：实现简单，运行高效，缺点是内存缩小为原来的一般，持续复制长生存期的对象则导致效率降低<br>标记-压缩算法<br>老年代特点，有人提出标记-整理算法，标记过程与标记-清除算法相同，但后续步骤是让所有存活的对象都向一端移动，然后清理掉端边界以外的内存<br>分代收集算法<br>GC分代基本假设：绝大部分对象生命周期非常短暂，存活时间短<br>Generational Collection算法，把java堆分为新生代和老年代，然后根据各个年代特点采用最适当的收集算法。新生代中，每次垃圾收集时发现有大批对象死去，就选用复制算法。老年代中，对象存活率高，没有额外空间进行分配担保，必须使用标记清除或者标记整理算法。<h3 id="垃圾收集器–垃圾收集算法的具体实现"><a href="#垃圾收集器–垃圾收集算法的具体实现" class="headerlink" title="垃圾收集器–垃圾收集算法的具体实现"></a>垃圾收集器–垃圾收集算法的具体实现</h3>Serial收集器<br>只使用一个线程去回收，新生代复制算法，老年代标记-整理，垃圾收集过程中会stop the world<br>Parallel收集器<br>新生代复制，来年代标记整理 新生代并行，老年代串行<br>Parallel Old收集器<br>使用Parallel收集器，老年代并行<br>CMS收集器<br>目的：最短回收停顿时间，初始标记，并发标记，重新标记，并发清除<br>优缺点：优点并发收集、停顿短，缺点产生大量空间碎片，并发阶段降低吞吐量<br>G集器<br>空间整合，不会产生空间碎片，可预测停顿。<br>G整个Java堆划分为多个大小相等的独立区域，新生代与老年代不再是物理隔阂了，都是一部分区域的集合<h3 id="CMS和G比较，以及G缺点，SS解决什么样的问题"><a href="#CMS和G比较，以及G缺点，SS解决什么样的问题" class="headerlink" title="CMS和G比较，以及G缺点，SS解决什么样的问题"></a>CMS和G比较，以及G缺点，SS解决什么样的问题</h3>CMS满足对相应时间的重要性需求大于对吞吐量的要求，内存中存在较多长生命周期的对象。</li></ul><p>CMS(Concurrent Mark-Sweep)是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动JVM参数加上-XX:+UseConcMarkSweepGC ，这个参数表示对于老年代的回收采用CMS。</p><ul><li>CMS回收器采用的基础算法是Mark-Sweep。所有CMS不会整理、压缩堆空间。这样就会有一个问题：经过CMS收集的堆会产生空间碎片。 CMS不对堆空间整理压缩节约了垃圾回收的停顿时间，但也带来的堆空间的浪费。为了解决堆空间浪费问题，CMS回收器不再采用简单的指针指向一块可用堆空 间来为下次对象分配使用。而是把一些未分配的空间汇总成一个列表，当JVM分配对象空间的时候，会搜索这个列表找到足够大的空间来hold住这个对象。</li><li>需要更多的CPU资源。从上面的图可以看到，为了让应用程序不停顿，CMS线程和应用程序线程并发执行，这样就需要有更多的CPU，单纯靠线程切 换是不靠谱的。并且，重新标记阶段，为空保证STW快速完成，也要用到更多的甚至所有的CPU资源。当然，多核多CPU也是未来的趋势！</li><li>CMS的另一个缺点是它需要更大的堆空间。因为CMS标记阶段应用程序的线程还是在执行的，那么就会有堆空间继续分配的情况，为了保证在CMS回 收完堆之前还有空间分配给正在运行的应用程序，必须预留一部分空间。也就是说，CMS不会在老年代满的时候才开始收集。相反，它会尝试更早的开始收集，已 避免上面提到的情况：在回收完成之前，堆没有足够空间分配！默认当老年代使用%的时候，CMS就开始行动了。</li></ul><p>G景，停顿时间可控，实时性较强，大幅度减少了长时间的GC,缺点会有一定程度的高吞吐。<br>应用程序具有如下一个或多个特征，适用于G而不是CMS<br> Full GC 次数太频繁或者消耗时间太长<br> 对象分配的频率或代数提升显式变化<br> 垃圾回收或内存整理时间较长</p><h2 id="线程同步与阻塞的关系，同步一定阻塞吗，阻塞一定同步吗"><a href="#线程同步与阻塞的关系，同步一定阻塞吗，阻塞一定同步吗" class="headerlink" title="线程同步与阻塞的关系，同步一定阻塞吗，阻塞一定同步吗"></a>线程同步与阻塞的关系，同步一定阻塞吗，阻塞一定同步吗</h2><p>两者没有必然关系，同步不一定阻塞，阻塞也不一定同步。</p><ul><li>同步异步<br>同步异步关注的是消息通信机制。<br>同步是发出一个调用时，没得到结果前，调用不返回，一旦返回得到返回值；异步是在调用发出后，直接返回，被调用者通过状态或通知来通知调用者或通过回调函数处理。</li><li>阻塞非阻塞<br>阻塞非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。<br>阻塞调用是指调用结果返回之前，当前线程会被挂起，调用线程在得到结果之后才会返回；非阻塞调用是指在不能立刻得到结果之前，该调用不会阻塞当前线程。</li></ul><h2 id="mysql的查询慢了，如何优化索引"><a href="#mysql的查询慢了，如何优化索引" class="headerlink" title="mysql的查询慢了，如何优化索引"></a>mysql的查询慢了，如何优化索引</h2><ul><li>开启慢查询日志，找到慢查询sql</li><li>通过explain查看执行计划,注意设置SQL_NO_CACHE关闭缓存</li><li>where条件单表查，查看字段区分度。</li><li>调整order by limit的顺序</li><li>查看索引是否符合索引建立原则：最左前缀匹配，mysql会已知向右匹配知道遇到范围查询（&gt;,&lt;,between,like)停止；= 和in可以乱序； 选择区分度高的列建立索引  索引列不能参与计算；尽量扩展索引  not in !=不会使用索引</li></ul><h2 id="Join操作时内部的原理，Join的时候大表驱动小表还是小表驱动大表，走索引的时候的复杂度是怎样的"><a href="#Join操作时内部的原理，Join的时候大表驱动小表还是小表驱动大表，走索引的时候的复杂度是怎样的" class="headerlink" title="Join操作时内部的原理，Join的时候大表驱动小表还是小表驱动大表，走索引的时候的复杂度是怎样的"></a>Join操作时内部的原理，Join的时候大表驱动小表还是小表驱动大表，走索引的时候的复杂度是怎样的</h2><p>应该使用小结果集驱动大结果集，join通过嵌套循环实现的，驱动结果集越大，需要循环次数越多。</p><h2 id="InnoDB的四种隔离机制，RC和RR的区别，以及在使用的时候有什么感受和问题"><a href="#InnoDB的四种隔离机制，RC和RR的区别，以及在使用的时候有什么感受和问题" class="headerlink" title="InnoDB的四种隔离机制，RC和RR的区别，以及在使用的时候有什么感受和问题"></a>InnoDB的四种隔离机制，RC和RR的区别，以及在使用的时候有什么感受和问题</h2><ul><li>第一级别 Read Uncommitted-RU   读取未提交内容</li><li>第二级别 Read Committed-RC     读取提交内容</li><li>第三级别 Repeatable Read-RR    可重复读</li><li>第四级别 Serializable       可串行化</li></ul><h3 id="第一级别-Read-Uncommitted（读取未提交内容）"><a href="#第一级别-Read-Uncommitted（读取未提交内容）" class="headerlink" title="第一级别 Read Uncommitted（读取未提交内容）"></a>第一级别 Read Uncommitted（读取未提交内容）</h3><p> 所有事务都可以看到其他未提交事务的执行结果<br> 本隔离级别很少实际应用，性能并不比其他级别好多少<br> 该级别引发的问题–脏读（Dirty Read）：读取到了未提交的数据</p><p>事务A,B:事务A开启事务，执行select，事务B开启事务，执行update；事务A在事务B执行update后即可查询到更新。</p><h3 id="第二级别-Read-Committed（读取提交内容）"><a href="#第二级别-Read-Committed（读取提交内容）" class="headerlink" title="第二级别 Read Committed（读取提交内容）"></a>第二级别 Read Committed（读取提交内容）</h3><p> 大多数数据库系统默认隔离级别（不是mysql默认）<br> 满足了隔离的简单定义：一个事务只能看见已经提交的事务所做的改变<br> 该级别引发问题–不可重复读（Nonrepeatable Read）：同一个事务中执行完全相同的select语句可能出现不同的结果—-&gt;原因：（有一个交叉的事务有新的commit，导致数据改变；（一个数据库被多实例操作时，同一事务的其他实例处理期间可能会有新的commit<br> 不同事务执行相同select时有可能会出现不同结果</p><p>事务A,B:事务A开启事务，执行select，事务B开启事务，执行update；事务A在事务B执行update后提交事务后，才可查询到更新。</p><h3 id="第三级别-Repeatable-Read-（可重复读）"><a href="#第三级别-Repeatable-Read-（可重复读）" class="headerlink" title="第三级别 Repeatable Read （可重复读）"></a>第三级别 Repeatable Read （可重复读）</h3><p> MySQL默认事务隔离级别<br> 确保同一事务的多个实例在并发读取数据时，看到相同的数据行<br> 该级别引发问题—幻读（Phantom Read）：当用户读取某一范围数据行时，另一个事务在该范围插入了新行，当用户再读取该范围数据行时，会发现有新的幻影行<br> InnoDB和Falcon存储引擎通过多版本并发控制（MVCC, Multiversion Concurrency Control）机制解决了该问题</p><p>事务A,B:事务A开启事务，执行select，事务B开启事务，执行update或insert；事务A在事务B执行update并提交后，事务A提交后方可查询到更新。</p><h3 id="第四级别-Serializable-（可串行化）"><a href="#第四级别-Serializable-（可串行化）" class="headerlink" title="第四级别 Serializable  （可串行化）"></a>第四级别 Serializable  （可串行化）</h3><p> 这是最高的隔离级别<br> 通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，是在每个读的数据行上加上共享锁<br> 在这个级别，可能导致大量的超时现象和锁竞争</p><p>事务A,B:事务A开启事务，执行select，事务B开启事务，执行update；事务B在事务A没有commit之前，是不能执行update更改数据的，只有A事务commit后，事务B方可执行update</p><p>脏读：读取到了未提交的数据<br>不可重复读：同一个事务中执行相同的select语句可能出现不同的结果<br>幻读：用户读取某一范围数据行时，另一个事务在该范围插入了新行，当用户再读取该范围数据行时，会发现有新的幻影行</p><h2 id="分布式主键生成方式有哪些中，优势和劣势是什么？SnowFlake算法具体是怎么实现的"><a href="#分布式主键生成方式有哪些中，优势和劣势是什么？SnowFlake算法具体是怎么实现的" class="headerlink" title="分布式主键生成方式有哪些中，优势和劣势是什么？SnowFlake算法具体是怎么实现的"></a>分布式主键生成方式有哪些中，优势和劣势是什么？SnowFlake算法具体是怎么实现的</h2><h3 id="使用数据库的auto-increment生成主键"><a href="#使用数据库的auto-increment生成主键" class="headerlink" title="使用数据库的auto_increment生成主键"></a>使用数据库的auto_increment生成主键</h3><p>优点： 简单  保证唯一 保证递增  步长固定<br>缺点：可用性难以保证，主库写存在单点故障  扩展性差，有性能上限</p><h3 id="单点批量ID生成服务"><a href="#单点批量ID生成服务" class="headerlink" title="单点批量ID生成服务"></a>单点批量ID生成服务</h3><p>优点：保证了ID生成的绝对递增有序 降低了数据库压力，性能高<br>缺点：服务存在单点故障  存在单点性能上限</p><h3 id="uuid"><a href="#uuid" class="headerlink" title="uuid"></a>uuid</h3><p>优点：本地生成ID 扩展性好<br>缺点：无法保证递增 uuid过长，索引查询效率低</p><h3 id="取当前毫秒数-微秒数"><a href="#取当前毫秒数-微秒数" class="headerlink" title="取当前毫秒数/微秒数"></a>取当前毫秒数/微秒数</h3><p>优点：本地生成，时延低  ID趋势递增  ID整数，索引查询效率高<br>缺点：毫秒并发超过，会生成重复ID</p><h3 id="SnowFlake算法-twitter开源的分布式ID生成算法"><a href="#SnowFlake算法-twitter开源的分布式ID生成算法" class="headerlink" title="SnowFlake算法 twitter开源的分布式ID生成算法"></a>SnowFlake算法 twitter开源的分布式ID生成算法</h3><p>毫秒数（bits）业务线 机房 机器(三项共位) 毫秒内序列号（共位） 拼接生成ID</p><h2 id="linux进程间的通信方式"><a href="#linux进程间的通信方式" class="headerlink" title="linux进程间的通信方式"></a>linux进程间的通信方式</h2><p>管道 信号量 信号 消息队列 共享内存 套接字 命名管道</p><h2 id="mysql索引失效的几种情况"><a href="#mysql索引失效的几种情况" class="headerlink" title="mysql索引失效的几种情况"></a>mysql索引失效的几种情况</h2><ul><li>条件中有or，除非or条件中每一列都加上索引</li><li>like查询以%开头</li><li>列类型是字符串，查询sql中要将数据使用引号引用起来</li></ul><h2 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h2><p>F:符合F的关系中的每个属性都不可再分<br>F:实体的属性完全依赖于主关键字。完全依赖是指不能存在仅依赖主关键字一部分的属性<br>F:任何非主属性不依赖于其他非主属性</p><h2 id="InnoDB主键索引与普通索引的区别和查询时的过程"><a href="#InnoDB主键索引与普通索引的区别和查询时的过程" class="headerlink" title="InnoDB主键索引与普通索引的区别和查询时的过程"></a>InnoDB主键索引与普通索引的区别和查询时的过程</h2><p>主键索引：加速查询+唯一值+表中只有一个+not null<br>普通索引：加速查询</p><h2 id="sql查询两个数据集的补集"><a href="#sql查询两个数据集的补集" class="headerlink" title="sql查询两个数据集的补集"></a>sql查询两个数据集的补集</h2><p>并集 union 结果集具有相同的结构 结果集列数 结果集对应的数据类型可以兼容 结果集不能包含order by和compute子句<br>差集 except 同上<br>交集 intersect 同上<br>补集 select * from a where (id) not (select id from b)</p><h2 id="mysql索引B-tree的原理"><a href="#mysql索引B-tree的原理" class="headerlink" title="mysql索引B-tree的原理"></a>mysql索引B-tree的原理</h2><h2 id="如何分库分表"><a href="#如何分库分表" class="headerlink" title="如何分库分表"></a>如何分库分表</h2><h3 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h3><ul><li>横向分表：横向切割为同样结构的不同表，表结构一样，根据特定规则来划分</li><li>纵向分表：多列拆分为两张表，冷热数据分离<h3 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h3></li><li>分库：每个库中表不同</li><li>分表：每个主机表相同</li></ul><h2 id="Linux下如何进行进程调度的"><a href="#Linux下如何进行进程调度的" class="headerlink" title="Linux下如何进行进程调度的"></a>Linux下如何进行进程调度的</h2><p>普通进程，实时进程。实时进程优先级高<br>实时进程：SCHED_FIFO 先进先出  SCHED_RR 轮转调度<br>普通进程：交互式进程 优先级较高 批处理进程 优先级较低</p><h2 id="redis-memcached区别，应用场景"><a href="#redis-memcached区别，应用场景" class="headerlink" title="redis memcached区别，应用场景"></a>redis memcached区别，应用场景</h2><ul><li>性能对比 redis使用单核，memcached可以使用多核，以上数据，memcached性能要高于redis</li><li>内存使用效率 使用简单kv存储，memcached内存利用率更高，如果redis采用hash结构来做kv存储，由于其组合式的压缩，其内存利用率高于memcached</li><li>redis支持服务器端的数据操作，支持复杂的结构和操作</li><li>memcached 多线程，非阻塞IO复用的网络模型，引入锁带来了性能损耗，redis使用单线程的IO复用模型</li><li>对数据持久化与数据同步有要求时，建议使用redis</li></ul><p>应用场景：</p><ul><li>redis：少量数据存储，高速读写访问，全部数据in-memory，提供数据落地功能</li><li>memcached：</li></ul><h2 id="如何解决Cookie盗取问题"><a href="#如何解决Cookie盗取问题" class="headerlink" title="如何解决Cookie盗取问题"></a>如何解决Cookie盗取问题</h2><ul><li>Cookie设置httponly,使得浏览器的document对象看不到cookie，不能再js中操作cookie</li><li>使用全站https</li><li>使用session或者固定时间过期的Cookie</li></ul><h2 id="线程同步工具类"><a href="#线程同步工具类" class="headerlink" title="线程同步工具类"></a>线程同步工具类</h2><ul><li>CountDownLatch–闭锁(一次性对象，进入终止状态后不能被重置)：同步工具类，可以使一个或多个线程等待一组事件发生。可以理解为一扇门，闭锁到达结束状态前门是关闭的，并且没有线程可以通过。达到结束状态时，门会打开允许所有线程通过。闭锁达到结束状态后，永远保持打开状态。可以用来确保某些活动指导其他活动都完成后才继续执行。</li><li>Semaphore–计数信号量：用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。还可以用来实现资源池或对容器施加边界。Semaphore中管理着一组虚拟的许可。</li><li>CyclicBarrier–栅栏：所有线程必须同时达到栅栏位置，才能继续执行，闭锁用于等待事件，栅栏用于等待其他线程。</li></ul><h2 id="给你三个线程，分别处理任务，再交给主线程，你如何实现。"><a href="#给你三个线程，分别处理任务，再交给主线程，你如何实现。" class="headerlink" title="给你三个线程，分别处理任务，再交给主线程，你如何实现。"></a>给你三个线程，分别处理任务，再交给主线程，你如何实现。</h2><ul><li>可以使用join方法等待</li><li>使用CountDownLatch</li></ul><h2 id="线程池底层实现"><a href="#线程池底层实现" class="headerlink" title="线程池底层实现"></a>线程池底层实现</h2><p>ExecutorService接口继承Executor接口，定义了终止，提交任务，跟踪任务返回结果等方法。</p><ul><li>execute(Runnable command)</li><li>submit(task) task可为Callable或Runnable</li><li>shutdown()</li><li>shutdownNow()</li><li>isTerminated()</li><li>isShutdown()<br>当创建线程池后，初始时，线程池处于RUNNING状态；<br>如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕，最后终止；<br>如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务，返回没有执行的任务列表；<br>当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态</li></ul><h2 id="servlet生命周期"><a href="#servlet生命周期" class="headerlink" title="servlet生命周期"></a>servlet生命周期</h2><ul><li>初始化阶段，调用init（）方法</li><li>响应客户端请求阶段，调用service（）方法</li><li>终止阶段，调用destroy（）方法</li></ul><h2 id="创建多线程的几种方式及区别"><a href="#创建多线程的几种方式及区别" class="headerlink" title="创建多线程的几种方式及区别"></a>创建多线程的几种方式及区别</h2><ul><li>继承Thread类</li><li>实现Runnable接口</li><li>使用Callable接口和Future</li><li>线程池ExecutorService</li></ul><h2 id="wait-sleep区别"><a href="#wait-sleep区别" class="headerlink" title="wait,sleep区别"></a>wait,sleep区别</h2><ul><li>sleep睡眠时，释放CPU资源，保持对象锁，依然持有该锁</li><li>wait等待时，释放对象锁</li></ul><h2 id="多线程实现同步方式–阻塞-互斥-同步，非阻塞同步"><a href="#多线程实现同步方式–阻塞-互斥-同步，非阻塞同步" class="headerlink" title="多线程实现同步方式–阻塞(互斥)同步，非阻塞同步"></a>多线程实现同步方式–阻塞(互斥)同步，非阻塞同步</h2><p>同步和异步关注的是消息通信机制：调用者*主动等待这个调用的结果。而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果<br>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态：阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><ul><li>阻塞同步：就是使用synchronized等进行的同步, 因为需要进行线程的阻塞与唤醒, 而这两个操作需要进行系统调用, 进行用户态与核心态的转换, 其性能影响较大，属于悲观的枷锁策略</li><li>非阻塞同步：即不使用synchronized等, 不会进行线程的阻塞与唤醒. 其实现往往依赖于乐观加锁策略。</li></ul><p>出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。<br>老张把水壶放到火上，立等水开。（同步阻塞）<br>老张觉得自己有点傻<br>老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）<br>老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。<br>老张把响水壶放到火上，立等水开。（异步阻塞）<br>老张觉得这样傻等意义不大<br>老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）<br>老张觉得自己聪明了。</p><p>所谓同步异步，只是对于水壶而言。<br>普通水壶，同步；响水壶，异步。<br>虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。<br>同步只能让调用者去轮询自己（情况），造成老张效率的低下。</p><p>所谓阻塞非阻塞，仅仅对于老张而言。<br>立等的老张，阻塞；看电视的老张，非阻塞。<br>情况情况老张就是阻塞的，媳妇喊他都不知道。虽然响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。</p><h2 id="java新特性，做一个List到Map的转换"><a href="#java新特性，做一个List到Map的转换" class="headerlink" title="java新特性，做一个List到Map的转换"></a>java新特性，做一个List到Map的转换</h2><p>List<account> list<br>list.stream().collect(Collectors.toMap(Account::id,Account::number))</account></p><h2 id="java线程池的实现，以及溢出的时候的抛弃策略"><a href="#java线程池的实现，以及溢出的时候的抛弃策略" class="headerlink" title="java线程池的实现，以及溢出的时候的抛弃策略"></a>java线程池的实现，以及溢出的时候的抛弃策略</h2><p>Java线程池会将提交的任务先置于工作队列中，在从工作队列中获取(SynchronousQueue直接由生产者提交给工作线程)。那么工作队列就有两种实现策略：无界队列和有界队列。无界队列不存在饱和的问题，但是其问题是当请求持续高负载的话，任务会无脑的加入工作队列，那么很可能导致内存等资源溢出或者耗尽。而有界队列不会带来高负载导致的内存耗尽的问题，但是有引发工作队列已满情况下，新提交的任务如何管理的难题，这就是线程池工作队列饱和策略要解决的问题。<br>饱和策略分为：Abort 策略, CallerRuns 策略,Discard策略，DiscardOlds策略。</p><ul><li>Abort策略：默认策略，队列满时提交新任务抛出未检查的异常</li><li>CallerRuns策略：调节机制，既不抛弃任务也不抛出异常，而是将某些任务回退给调用者，会在线程池的线程中执行新的任务，而是在调用executor的线程中运行新的任务</li><li>Discard策略：新提交的任务被抛弃，不抛出异常</li><li>DiscardOldest策略：队列执行队头任务，然后尝试提交新任务，不适合工作队列为优先队列</li></ul><h2 id="针对不同场景，如何去设计线程池的大小，怎样计算线程池的大小"><a href="#针对不同场景，如何去设计线程池的大小，怎样计算线程池的大小" class="headerlink" title="针对不同场景，如何去设计线程池的大小，怎样计算线程池的大小"></a>针对不同场景，如何去设计线程池的大小，怎样计算线程池的大小</h2><p>如果是CPU密集型应用，则线程池大小设置为N+1<br>如果是IO密集型应用，则线程池大小设置为+1<br>最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）<em> CPU数目<br>最佳线程数目 = （线程等待时间与线程CPU时间之比 + </em> CPU数目</p><ul><li>高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+减少线程上下文的切换</li><li>并发不高、任务执行时间长的业务要区分开看：<br>　<em> 假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以适当加大线程池中的线程数目，让CPU处理更多的业务　</em> 假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</li><li>并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。</li></ul><h2 id="JAVA反射机制，框架哪里设计过java的反射机制。通过反射调用一个方法，可以获取什么信息"><a href="#JAVA反射机制，框架哪里设计过java的反射机制。通过反射调用一个方法，可以获取什么信息" class="headerlink" title="JAVA反射机制，框架哪里设计过java的反射机制。通过反射调用一个方法，可以获取什么信息"></a>JAVA反射机制，框架哪里设计过java的反射机制。通过反射调用一个方法，可以获取什么信息</h2><p>spring ioc 加载类，<br>getDeclaredMethods可以获取类或接口声明的所有方法，包括公共，保护，默认访问和私有方法，但不包括继承的方法。<br>getMethods可以获取某个类的所有public方法，包括其继承类的公用方法。</p><h2 id="springmvc原理"><a href="#springmvc原理" class="headerlink" title="springmvc原理"></a>springmvc原理</h2><p>基于mvc的web框架</p><ul><li>发起请求到前端控制器(DispatcherServlet);</li><li>前端控制器请求HandlerMapping查找Handler，可以根据xml配置、注解进行查找；</li><li>处理器映射器HandlerMapping向前端控制器返回Handler；</li><li>前端控制器调用处理器适配器去执行Handler；</li><li>处理器适配器去执行Handler；</li><li>Handler执行完成给适配器返回ModelAndView；</li><li>处理器适配器向前端控制器返回ModelAndView(是springmvc框架的一个底层对象，包括Model和View)；</li><li>前端控制器请求视图解析器去进行视图解析，根据逻辑视图名称解析真正的视图(jsp…)；</li><li>视图解析器向前端控制器返回View;</li><li>前端控制器进行视图渲染，视图渲染就是将模型数据(在ModelAndView对象中)填充到request域中。</li><li>前端控制器向用户响应结果。</li></ul><h2 id="Full-GC和Minor-GC区别，各自触发条件"><a href="#Full-GC和Minor-GC区别，各自触发条件" class="headerlink" title="Full GC和Minor GC区别，各自触发条件"></a>Full GC和Minor GC区别，各自触发条件</h2><h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p>从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC。<br>触发条件：<br>有一些值得注意的问题：</p><ul><li>当 JVM 无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了。所以分配率越高，越频繁执行 Minor GC。</li><li>内存池被填满的时候，其中的内容全部会被复制，指针会从0开始跟踪空闲内存。Eden 和 Survivor 区进行了标记和复制操作，取代了经典的标记、扫描、压缩、清理操作。所以 Eden 和 Survivor 区不存在内存碎片。写指针总是停留在所使用内存池的顶部。</li><li>执行 Minor GC 操作时，不会影响到永久代。从永久代到年轻代的引用被当成 GC roots，从年轻代到永久代的引用在标记阶段被直接忽略掉。</li><li>质疑常规的认知，所有的 Minor GC 都会触发“全世界的暂停（stop-the-world）”，停止应用程序的线程。对于大部分应用程序，停顿导致的延迟都是可以忽略不计的。其中的真相就是，大部分 Eden 区中的对象都能被认为是垃圾，永远也不会被复制到 Survivor 区或者老年代空间。如果正好相反，Eden 区大部分新生对象不符合 GC 条件，Minor GC 执行时暂停的时间将会长很多。<br>每次 Minor GC 会清理年轻代的内存。<h3 id="Major-GC-Full-GC"><a href="#Major-GC-Full-GC" class="headerlink" title="Major GC/Full GC"></a>Major GC/Full GC</h3>Major GC 是清理永久代。<br>Full GC 是清理整个堆空间—包括年轻代和永久代。</li></ul><h2 id="JMM内存模型，如何保证缓存一致性"><a href="#JMM内存模型，如何保证缓存一致性" class="headerlink" title="JMM内存模型，如何保证缓存一致性"></a>JMM内存模型，如何保证缓存一致性</h2><p>JMM是Java程序对线程如何交互的统一的约定协议<br>Happens-Before 顺序: 保证了一个线程的操作结果能够对另一个线程可见<br>synchronized关键字提供互斥区和内存可见性, 防止重排序<br>volatile提供内存可见性,防止重排序，保证64位元素(double、long)的原子性读写</p><h2 id="CMS垃圾回收器及其应用场景"><a href="#CMS垃圾回收器及其应用场景" class="headerlink" title="CMS垃圾回收器及其应用场景"></a>CMS垃圾回收器及其应用场景</h2><p>老年代 集中在互联网站或B/S系统服务端上的Java应用</p><h2 id="hashmap，如何处理hash冲突，为什么hashmap允许null值，resize过程，多线程下resize为什么会出现死循环"><a href="#hashmap，如何处理hash冲突，为什么hashmap允许null值，resize过程，多线程下resize为什么会出现死循环" class="headerlink" title="hashmap，如何处理hash冲突，为什么hashmap允许null值，resize过程，多线程下resize为什么会出现死循环"></a>hashmap，如何处理hash冲突，为什么hashmap允许null值，resize过程，多线程下resize为什么会出现死循环</h2><p>将相同hash值的对象组织成一个链表放在hash值对应的槽位。</p><h2 id="java跳表的并发问题"><a href="#java跳表的并发问题" class="headerlink" title="java跳表的并发问题"></a>java跳表的并发问题</h2><p>Skip list的性质</p><ul><li>由很多层结构组成，level是通过一定的概率随机产生的。</li><li>每一层都是一个有序的链表，默认是升序</li><li>最底层(Level 1)的链表包含所有元素。</li><li>如果一个元素出现在Level i 的链表中，则它在Level i 之下的链表也都会出现。</li><li>每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。<br>ConcurrentSkipListMap具有Skip list的性质 ，并且适用于大规模数据的并发访问。多个线程可以安全地并发执行插入、移除、更新和访问操作。与其他有锁机制的数据结构在巨大的压力下相比有优势。</li></ul><h2 id="NIO-BIO-AIO"><a href="#NIO-BIO-AIO" class="headerlink" title="NIO,BIO,AIO"></a>NIO,BIO,AIO</h2><p>BIO，同步阻塞式IO，简单理解：一个连接一个线程<br>NIO，同步非阻塞IO，简单理解：一个请求一个线程<br>AIO，异步非阻塞IO，简单理解：一个有效请求一个线程<br>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。<br>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。<br>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p><h2 id="什么是二叉平衡树，如何插入节点，删除节点，说出关键步骤"><a href="#什么是二叉平衡树，如何插入节点，删除节点，说出关键步骤" class="headerlink" title="什么是二叉平衡树，如何插入节点，删除节点，说出关键步骤"></a>什么是二叉平衡树，如何插入节点，删除节点，说出关键步骤</h2><p>二叉平衡树，又称AVL树。它或者是一棵空树，或者是具有下列性质的树：</p><ul><li>具备二叉排序树的所有性质；</li><li>左子树和右子树深度差的绝对值不超过1；</li><li>左子树和右子树都是二叉平衡树。<br>根节点插入，判断是否存在，否则左子树递归查找插入，如插入未成功，则在右子树递归查找插入。插入结束后判断是否需要自旋</li></ul><h2 id="什么是一致性hash"><a href="#什么是一致性hash" class="headerlink" title="什么是一致性hash"></a>什么是一致性hash</h2><p>环形分段hash，防止hash偏斜，可通过物理节点虚拟出虚拟节点来解决</p><h2 id="Arraylist如何实现排序"><a href="#Arraylist如何实现排序" class="headerlink" title="Arraylist如何实现排序"></a>Arraylist如何实现排序</h2><p>Collections.sort() 方法对 ArrayList 的元素或者任何其他 List 的实现提供的可比较的元素进行排序，这意味着这些元素的类需要实现 java.lang 包中的 Comparable 接口<br>一种是使用 Comparable 另一种是使用 Comparator。你最应该记住的就是一个 Comparable 对象可以说“我可以自己与另外一个对象比较”，而一个 Comparator 对象可以说“我可以比较两个不同的对象”</p><h2 id="Zookeeper的使用场景"><a href="#Zookeeper的使用场景" class="headerlink" title="Zookeeper的使用场景"></a>Zookeeper的使用场景</h2><ul><li>数据发布与订阅（配置中心）：发布与订阅模型，即所谓的配置中心，顾名思义就是发布者将数据发布到ZK节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新。例如全局的配置信息，服务式服务框架的服务地址列表等就非常适合使用。</li><li>负载均衡 kafka：这里说的负载均衡是指软负载均衡。在分布式环境中，为了保证高可用性，通常同一个应用或同一个服务的提供方都会部署多份，达到对等服务。而消费者就须要在这些对等的服务器中选择一个来执行相关的业务逻辑，其中比较典型的是消息中间件中的生产者，消费者负载均衡。</li><li>命名服务（naming service）dubbo：命名服务也是分布式系统中比较常见的一类场景。在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。被命名的实体通常可以是集群中的机器，提供的服务地址，远程对象等等——这些我们都可以统称他们为名字（Name）。其中较为常见的就是一些分布式服务框架中的服务地址列表。通过调用ZK提供的创建节点的API，能够很容易创建一个全局唯一的path，这个path就可以作为一个名称。<br>Dubbo中使用ZooKeeper来作为其命名服务，维护全局的服务地址列表</li><li>集群管理与Master选举</li><li>分布式锁</li><li>分布式队列</li><li>分布式通知/协调</li></ul><h2 id="spring的annotation实现"><a href="#spring的annotation实现" class="headerlink" title="spring的annotation实现"></a>spring的annotation实现</h2><p>注解（Annotation）提供了一种安全的类似注释的机制，为我们在代码中添加信息提供了一种形式化得方法，使我们可以在稍后某个时刻方便的使用这些数据（通过解析注解来使用这些数据），用来将任何的信息或者元数据与程序元素（类、方法、成员变量等）进行关联。其实就是更加直观更加明了的说明，这些说明信息与程序业务逻辑没有关系，并且是供指定的工具或框架使用的。Annotation像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的申明语句中。<br>Annotation其实是一种接口。通过java的反射机制相关的API来访问Annotation信息。相关类（框架或工具中的类）根据这些信息来决定如何使用该程序元素或改变它们的行为。Java语言解释器在工作时会忽略这些Annotation，因此在JVM中这些Annotation是“不起作用”的，只能通过配套的工具才能对这些Annotation类型的信息进行访问和处理。</p><h2 id="spring的Bean的生命周期"><a href="#spring的Bean的生命周期" class="headerlink" title="spring的Bean的生命周期"></a>spring的Bean的生命周期</h2><ul><li>实例化BeanFactoryPostProcessor实现类</li><li>执行BeanFactoryPostProcessor的postProcessBeanFactory方法</li><li>实例化BeanPostProcessor实现类</li><li>实例化InstantiationAwareBeanPostProcessorAdapter实现类</li><li>执行InstantiationAwareBeanPostProcessor的postProcessBeforeInstantiation方法</li><li>执行Bean构造器</li><li>执行InstantiationAwareBeanPostProcessor的postProcessPropertyValues方法</li><li>为Bean注入属性</li><li>调用BeanNameAware的setBeanName方法</li><li>调用BeanFactoryAware的setBeanFactory方法</li></ul><h2 id="内存溢出的原因是什么，排查方法有哪些"><a href="#内存溢出的原因是什么，排查方法有哪些" class="headerlink" title="内存溢出的原因是什么，排查方法有哪些"></a>内存溢出的原因是什么，排查方法有哪些</h2><ul><li>是否App中的类中和引用变量过多使用了Static修饰 如public staitc Student s</li><li>是否App中使用了大量的递归或无限递归（递归中用到了大量的建新的对象）</li><li>是否App中使用了大量循环或死循环（循环中用到了大量的新建的对象）</li><li>检查App中是否使用了向数据库查询所有记录的方法。即一次性全部查询的方法，如果数据量超过10万多条了，就可能会造成内存溢出。所以在查询时应采用“分页查询”。</li><li>检查是否使用了“非字面量字符串进行+”的操作。因为String类的内容是不可变的，每次运行”+”就会产生新的对象，如果过多会造成新String对象过多，从而导致JVM没有及时回收而出现内存溢出。</li><li>使用 DDMS工具进行查找内存溢出的大概位置<br>排查方法：<a href="https://my.oschina.net/vbird/blog/1518938" target="_blank" rel="noopener">https://my.oschina.net/vbird/blog/1518938</a></li></ul><h2 id="jmap-jstat-jinfo-jps-jconsole-mat-jprofile"><a href="#jmap-jstat-jinfo-jps-jconsole-mat-jprofile" class="headerlink" title="jmap jstat jinfo jps jconsole mat jprofile"></a>jmap jstat jinfo jps jconsole mat jprofile</h2><h3 id="jmap：查看heap情况，如查看存活对象列表"><a href="#jmap：查看heap情况，如查看存活对象列表" class="headerlink" title="jmap：查看heap情况，如查看存活对象列表"></a>jmap：查看heap情况，如查看存活对象列表</h3><ul><li>jmap -heap pid → 查看堆的使用状况信息</li><li>jmap -histo:live pid | less → 堆中活动的对象以及大小</li><li>jmap -dump:format=b,file=eclipse_heap.bin pid → Dump堆信息<h3 id="jstat：观察GC情况"><a href="#jstat：观察GC情况" class="headerlink" title="jstat：观察GC情况"></a>jstat：观察GC情况</h3>可以查看很多内容 jstat -gcutil -h 20 pid 1000 100 → 查看Java进程GC的情况，1000ms统计一次gc情况统计100次<h3 id="jstack：分析线程堆栈"><a href="#jstack：分析线程堆栈" class="headerlink" title="jstack：分析线程堆栈"></a>jstack：分析线程堆栈</h3>查看jvm线程运行状态，是否有死锁现象等等信息</li><li>jstack pid → Dump线程信息<h3 id="jinfo，查看jvm配置信息"><a href="#jinfo，查看jvm配置信息" class="headerlink" title="jinfo，查看jvm配置信息"></a>jinfo，查看jvm配置信息</h3><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><h3 id="jhat：分析dump的堆文件"><a href="#jhat：分析dump的堆文件" class="headerlink" title="jhat：分析dump的堆文件"></a>jhat：分析dump的堆文件</h3><h3 id="jconsole，图形界面。可以持续收集内存、线程信息，并以曲线的方式显示出来。"><a href="#jconsole，图形界面。可以持续收集内存、线程信息，并以曲线的方式显示出来。" class="headerlink" title="jconsole，图形界面。可以持续收集内存、线程信息，并以曲线的方式显示出来。"></a>jconsole，图形界面。可以持续收集内存、线程信息，并以曲线的方式显示出来。</h3>这个工具真正要做的功能是查看JMX Bean的信息，性能分析中并不关心JMX信息。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集的Java经典面试题&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="interview" scheme="http://gitqh.github.io/categories/interview/"/>
    
    
  </entry>
  
  <entry>
    <title>Sublime Text 插件篇</title>
    <link href="http://gitqh.github.io/2017/09/11/Sublime_plugin/"/>
    <id>http://gitqh.github.io/2017/09/11/Sublime_plugin/</id>
    <published>2017-09-11T07:17:34.000Z</published>
    <updated>2017-09-28T04:50:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>Sublime Text支持丰富的扩展及插件，使其在前端开发与编写动态语言时具有可以媲美IDE的效率。本文以Sublime Text3为例，分类别对常用插件进行简单的介绍。</p><p><strong>建议：</strong>阅读本文前，请先阅读<a href="/2016/03/22/Sublime_basic/">Sublime Text 入门篇</a></p><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a><a name="catalog">目录</a></h2><p><a href="#chart1">1.  格式化（Format）</a></p><p><a href="#chart2">2.  智能提示（Intelligent Prompt）</a></p><p><a href="#chart3">3.  编码（Encoding）</a></p><p><a href="#chart4">4.  版本控制（Version Control）</a></p><p><a href="#chart5">5.  前端必备（Web UI）</a></p><p><a href="#chart6">6.  功能增强（Enhancement）</a></p><p><a href="#chart7">7.  个人插件快捷键配置（Personal Settings）</a></p><hr><a id="more"></a><h2 id="格式化（Format）"><a href="#格式化（Format）" class="headerlink" title="格式化（Format）"></a><a name="chart1">格式化（Format）</a></h2><h3 id="Alignment"><a href="#Alignment" class="headerlink" title="Alignment"></a><a href="https://github.com/wbond/sublime_alignment" target="_blank" rel="noopener">Alignment</a></h3><ul><li><p>简介：变量定义太多，可以一键使 “=” 对齐</p></li><li><p>使用：默认快捷键 <code>Ctrl + Alt + A</code> 与qq截屏快捷键冲突，可以设置其他快捷键如 <code>Ctrl + Shift + Alt + A</code></p></li></ul><p><img src="/temp/sublime_plugin/align.gif" alt=""></p><h3 id="TrailingSpacers"><a href="#TrailingSpacers" class="headerlink" title="TrailingSpacers"></a><a href="https://github.com/SublimeText/TrailingSpaces" target="_blank" rel="noopener">TrailingSpacers</a></h3><ul><li><p>简介：TrailingSpacers这款插件可以高亮显示多余的空格及空行，并可以一键删除。</p></li><li><p>使用：安装插件需重启Sublime，可在快捷键配置文件Key Binding-User中设置快捷键 <code>Ctrl + Alt + D</code></p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"keys"</span>: [<span class="string">"ctrl+alt+d"</span>],</span><br><span class="line">    <span class="attr">"command"</span>: <span class="string">"delete_trailing_spaces"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>效果：</li></ul><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/SublimePlugin_spac.gif" alt=""></p><h3 id="JSFormat"><a href="#JSFormat" class="headerlink" title="JSFormat"></a><a href="https://github.com/jdc0589/JsFormat" target="_blank" rel="noopener">JSFormat</a></h3><ul><li><p>简介：JSFormat插件可以帮助我们将经过压缩或混淆处理的js代码处理为标准格式，包括换行及缩进。</p></li><li><p>使用：在已压缩的JS文件中，右键选择jsFormat或者使用自定义快捷键 <code>Ctrl + Alt + L</code></p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"keys"</span>: [<span class="string">"ctrl+alt+l"</span>],</span><br><span class="line">    <span class="attr">"command"</span>: <span class="string">"js_format"</span>,</span><br><span class="line">    <span class="attr">"context"</span>: [&#123;<span class="attr">"key"</span>: <span class="string">"selector"</span>, <span class="attr">"operator"</span>: <span class="string">"equal"</span>, <span class="attr">"operand"</span>: <span class="string">"source.js,source.json"</span>&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>效果：</li></ul><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/SublimePlugin_jsFormat.gif" alt=""></p><p><a href="#catalog"><p style="text-align: right">回到目录</p></a></p><hr><h2 id="智能提示（Intelligent-Prompt）"><a href="#智能提示（Intelligent-Prompt）" class="headerlink" title="智能提示（Intelligent Prompt）"></a><a name="chart2">智能提示（Intelligent Prompt）</a></h2><h3 id="LESS"><a href="#LESS" class="headerlink" title="LESS"></a><a href="https://packagecontrol.io/packages/LESS" target="_blank" rel="noopener">LESS</a></h3><ul><li><p>简介：使用该插件，可以支持less语法高亮</p></li><li><p>使用：打开.less文件或者使用快捷键 <code>Ctrl + Shift + P</code>，输入SSL</p></li></ul><h3 id="Bracket-Highlighter"><a href="#Bracket-Highlighter" class="headerlink" title="Bracket Highlighter"></a><a href="https://github.com/facelessuser/BracketHighlighter" target="_blank" rel="noopener">Bracket Highlighter</a></h3><ul><li><p>简介：可匹配[], (), {}, “”, ”, <tag></tag>，高亮标记，便于查看起始和结束标记</p></li><li><p>使用：点击对应代码</p></li><li><p>效果：</p></li></ul><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/SublimePlugin_highlight.gif" alt=""></p><h3 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a><a href="https://github.com/mrmartineau/Jquery" target="_blank" rel="noopener">jQuery</a></h3><ul><li><p>简介：对jQuery函数进行智能提示</p></li><li><p>效果：</p></li></ul><p><img src="/temp/sublime_plugin/jquery.gif" alt=""></p><h3 id="AutoFileName"><a href="#AutoFileName" class="headerlink" title="AutoFileName"></a><a href="https://packagecontrol.io/packages/AutoFileName" target="_blank" rel="noopener">AutoFileName</a></h3><ul><li><p>简介：自动完成文件名的输入，如图片选取等</p></li><li><p>使用：输入”/”即可看到相对于本项目文件夹的其他文件</p></li><li><p>效果：</p></li></ul><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/SublimePlugin_autofilename.gif" alt=""></p><h3 id="AngularJS"><a href="#AngularJS" class="headerlink" title="AngularJS"></a>AngularJS</h3><ul><li>简介：对AngularJS函数进行智能提示</li></ul><h3 id="JSLint"><a href="#JSLint" class="headerlink" title="JSLint"></a><a href="">JSLint</a></h3><ul><li><p>简介：对js代码进行质量检测</p></li><li><p>使用：按下 <code>Shift + Ctrl + P</code> 调出命令面板，找到JSLint: Run JSLint，按下Enter，JSLint会输出结果到状态栏</p></li><li><p>效果：</p></li></ul><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/SublimePlugin_03144051_IHwI.png" alt=""></p><p><a href="#catalog"><p style="text-align: right">回到目录</p></a></p><hr><h2 id="编码（Encoding）"><a href="#编码（Encoding）" class="headerlink" title="编码（Encoding）"></a><a name="chart3">编码（Encoding）</a></h2><h3 id="ConvertToUTF8"><a href="#ConvertToUTF8" class="headerlink" title="ConvertToUTF8"></a><a href="https://github.com/seanliang/ConvertToUTF8" target="_blank" rel="noopener">ConvertToUTF8</a></h3><ul><li><p>简介：Sublime Text默认不支持UTF8编码，通过本插件可以将GB2312，GBK，BIG5，EUC-KR，EUC-JP ，ANSI等编码格式文件自动转换为UTF8格式。</p></li><li><p>使用：安装插件自动转换为UTF8格式</p></li><li><p>效果：</p></li></ul><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/SublimePlugin_uy67y.gif" alt=""></p><p><a href="#catalog"><p style="text-align: right">回到目录</p></a></p><hr><h2 id="版本控制（Version-Control）"><a href="#版本控制（Version-Control）" class="headerlink" title="版本控制（Version Control）"></a><a name="chart4">版本控制（Version Control）</a></h2><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a><a href="https://github.com/kemayo/sublime-text-git" target="_blank" rel="noopener">Git</a></h3><ul><li><p>简介：实现了Git的基本功能</p></li><li><p>使用：<a href="https://github.com/kemayo/sublime-text-git/wiki" target="_blank" rel="noopener">https://github.com/kemayo/sublime-text-git/wiki</a></p></li><li><p>效果：</p></li></ul><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/SublimePlugin_git.png" alt=""></p><p><a href="#catalog"><p style="text-align: right">回到目录</p></a></p><hr><h2 id="前端必备（Web-UI）"><a href="#前端必备（Web-UI）" class="headerlink" title="前端必备（Web UI）"></a><a name="chart5">前端必备（Web UI）</a></h2><h3 id="Emmet"><a href="#Emmet" class="headerlink" title="Emmet"></a><a href="https://github.com/sergeche/emmet-sublime" target="_blank" rel="noopener">Emmet</a></h3><ul><li><p>简介：Emmet前身是前端神器zen coding，可以大幅度提高前端开发效率。你可以使用仿CSS选择器的语法来动态生成代码，编写HTML/CSS时有较明显的优势。</p></li><li><p>使用：使用方法请参照教程<a href="http://www.w3cplus.com/tools/emmet-cheat-sheet.html" target="_blank" rel="noopener">http://www.w3cplus.com/tools/emmet-cheat-sheet.html</a></p></li></ul><h3 id="ColorPicker"><a href="#ColorPicker" class="headerlink" title="ColorPicker"></a><a href="https://github.com/weslly/ColorPicker" target="_blank" rel="noopener">ColorPicker</a></h3><ul><li><p>简介：需要输入颜色时，可直接调出windows调色板选取颜色</p></li><li><p>使用：快捷键Windows: <code>Ctrl + Shift + C</code></p></li><li><p>效果：</p></li></ul><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/SublimePlugin_iY1DDCRG5TsyR.png" alt=""></p><p><a href="#catalog"><p style="text-align: right">回到目录</p></a></p><hr><h2 id="功能增强（Enhancement）"><a href="#功能增强（Enhancement）" class="headerlink" title="功能增强（Enhancement）"></a><a name="chart6">功能增强（Enhancement）</a></h2><h3 id="Markdown-Preview"><a href="#Markdown-Preview" class="headerlink" title="Markdown Preview"></a><a href="https://github.com/revolunet/sublimetext-markdown-preview" target="_blank" rel="noopener">Markdown Preview</a></h3><ul><li><p>简介：可以直接打开浏览器预览markdown文件</p></li><li><p>使用：安装完插件重启后，按 <code>Ctrl + Shift + P</code> ，选择Set Syntax:Markdown</p></li></ul><h3 id="DocBlockr"><a href="#DocBlockr" class="headerlink" title="DocBlockr"></a><a href="https://github.com/NikhilKalige/docblockr" target="_blank" rel="noopener">DocBlockr</a></h3><ul><li><p>简介：生成注释，包括函数名，参数，返回值等</p></li><li><p>使用：输入/*、/**然后回车，还有很多用法，请参照<a href="https://sublime.wbond.net/packages/DocBlockr" target="_blank" rel="noopener">https://sublime.wbond.net/packages/DocBlockr</a></p></li><li><p>效果：</p></li></ul><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/SublimePlugin_function-template.gif" alt=""></p><h3 id="IMESupport"><a href="#IMESupport" class="headerlink" title="IMESupport"></a><a href="https://github.com/chikatoike/IMESupport" target="_blank" rel="noopener">IMESupport</a></h3><ul><li><p>简介：使用中文输入法时，可以实现光标跟随（默认不可以）</p></li><li><p>效果：</p></li></ul><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/SublimePlugin_c1608aa0gw1e9dmrd3vxpg209y08d75x.gif" alt=""></p><h3 id="SideBarEnhancements"><a href="#SideBarEnhancements" class="headerlink" title="SideBarEnhancements"></a><a href="https://github.com/titoBouzout/SideBarEnhancements" target="_blank" rel="noopener">SideBarEnhancements</a></h3><ul><li><p>简介：SideBarEnhancements是一个可以自定义打开方式快捷键的工具包。他可以定义不同的快捷键打开不同的浏览器。</p></li><li><p>使用：安装插件并重启后，配置用户快捷键</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    //firefox</span><br><span class="line">    &#123; <span class="attr">"keys"</span>: [<span class="string">"f4"</span>], <span class="attr">"command"</span>: <span class="string">"side_bar_files_open_with"</span>,</span><br><span class="line">        <span class="attr">"args"</span>: &#123;</span><br><span class="line">            <span class="attr">"paths"</span>: [],</span><br><span class="line">            <span class="attr">"application"</span>: <span class="string">"C:/Program Files (x86)/Mozilla Firefox/firefox.exe"</span>,</span><br><span class="line">            <span class="attr">"extensions"</span>:<span class="string">".*"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // ie</span><br><span class="line">    &#123; <span class="attr">"keys"</span>: [<span class="string">"f5"</span>], <span class="attr">"command"</span>: <span class="string">"side_bar_files_open_with"</span>,</span><br><span class="line">         <span class="attr">"args"</span>: &#123;</span><br><span class="line">            <span class="attr">"paths"</span>: [],</span><br><span class="line">            <span class="attr">"application"</span>: <span class="string">"C:/Program Files/Internet Explorer/iexplore.exe"</span>,</span><br><span class="line">            <span class="attr">"extensions"</span>:<span class="string">" .*"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // chrome</span><br><span class="line">    &#123; <span class="attr">"keys"</span>: [<span class="string">"f6"</span>], <span class="attr">"command"</span>: <span class="string">"side_bar_files_open_with"</span>,</span><br><span class="line">        <span class="attr">"args"</span>: &#123;</span><br><span class="line">            <span class="attr">"paths"</span>: [],</span><br><span class="line">            <span class="attr">"application"</span>: <span class="string">"C:/Program Files (x86)/Google/Chrome/Application/chrome.exe"</span>,</span><br><span class="line">            <span class="attr">"extensions"</span>:<span class="string">".*"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FileDiffs"><a href="#FileDiffs" class="headerlink" title="FileDiffs"></a><a href="https://github.com/colinta/SublimeFileDiffs" target="_blank" rel="noopener">FileDiffs</a></h3><ul><li><p>简介：比较当前文件与选中的代码、剪切板中代码、另一文件、未保存文件之间的差别。</p></li><li><p>使用：右键标签页，出现FileDiffs Menu或者Diff with Tab，对应文件比较即可</p></li><li><p>效果：</p></li></ul><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/SublimePlugin_diff.gif" alt=""></p><p><a href="#catalog"><p style="text-align: right">回到目录</p></a></p><hr><h2 id="个人插件快捷键配置（Personal-Settings）"><a href="#个人插件快捷键配置（Personal-Settings）" class="headerlink" title="个人插件快捷键配置（Personal Settings）"></a><a name="chart7">个人插件快捷键配置（Personal Settings）</a></h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[</span><br><span class="line">    // layout</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"keys"</span>: [<span class="string">"ctrl+shift+q"</span>],</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"set_layout"</span>,</span><br><span class="line">        <span class="attr">"args"</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"cols"</span>: [<span class="number">0.0</span>, <span class="number">1.0</span>],</span><br><span class="line">            <span class="attr">"rows"</span>: [<span class="number">0.0</span>, <span class="number">1.0</span>],</span><br><span class="line">            <span class="attr">"cells"</span>: [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"keys"</span>: [<span class="string">"ctrl+shift+w"</span>],</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"set_layout"</span>,</span><br><span class="line">        <span class="attr">"args"</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"cols"</span>: [<span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>],</span><br><span class="line">            <span class="attr">"rows"</span>: [<span class="number">0.0</span>, <span class="number">1.0</span>],</span><br><span class="line">            <span class="attr">"cells"</span>: [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"keys"</span>: [<span class="string">"ctrl+shift+e"</span>],</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"set_layout"</span>,</span><br><span class="line">        <span class="attr">"args"</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"cols"</span>: [<span class="number">0.0</span>, <span class="number">0.33</span>, <span class="number">0.66</span>, <span class="number">1.0</span>],</span><br><span class="line">            <span class="attr">"rows"</span>: [<span class="number">0.0</span>, <span class="number">1.0</span>],</span><br><span class="line">            <span class="attr">"cells"</span>: [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"keys"</span>: [<span class="string">"ctrl+shift+r"</span>],</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"set_layout"</span>,</span><br><span class="line">        <span class="attr">"args"</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"cols"</span>: [<span class="number">0.0</span>, <span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>, <span class="number">1.0</span>],</span><br><span class="line">            <span class="attr">"rows"</span>: [<span class="number">0.0</span>, <span class="number">1.0</span>],</span><br><span class="line">            <span class="attr">"cells"</span>: [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"keys"</span>: [<span class="string">"ctrl+shift+y"</span>],</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"set_layout"</span>,</span><br><span class="line">        <span class="attr">"args"</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"cols"</span>: [<span class="number">0.0</span>, <span class="number">1.0</span>],</span><br><span class="line">            <span class="attr">"rows"</span>: [<span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>],</span><br><span class="line">            <span class="attr">"cells"</span>: [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"keys"</span>: [<span class="string">"ctrl+shift+u"</span>],</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"set_layout"</span>,</span><br><span class="line">        <span class="attr">"args"</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"cols"</span>: [<span class="number">0.0</span>, <span class="number">1.0</span>],</span><br><span class="line">            <span class="attr">"rows"</span>: [<span class="number">0.0</span>, <span class="number">0.33</span>, <span class="number">0.66</span>, <span class="number">1.0</span>],</span><br><span class="line">            <span class="attr">"cells"</span>: [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"keys"</span>: [<span class="string">"ctrl+shift+t"</span>],</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"set_layout"</span>,</span><br><span class="line">        <span class="attr">"args"</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"cols"</span>: [<span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>],</span><br><span class="line">            <span class="attr">"rows"</span>: [<span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>],</span><br><span class="line">            <span class="attr">"cells"</span>:</span><br><span class="line">            [</span><br><span class="line">                [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">                [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    //firefox</span><br><span class="line">    &#123; <span class="attr">"keys"</span>: [<span class="string">"f4"</span>], <span class="attr">"command"</span>: <span class="string">"side_bar_files_open_with"</span>,</span><br><span class="line">        <span class="attr">"args"</span>: &#123;</span><br><span class="line">            <span class="attr">"paths"</span>: [],</span><br><span class="line">            <span class="attr">"application"</span>: <span class="string">"C:/Program Files (x86)/Mozilla Firefox/firefox.exe"</span>,</span><br><span class="line">            <span class="attr">"extensions"</span>:<span class="string">".*"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // ie</span><br><span class="line">    &#123; <span class="attr">"keys"</span>: [<span class="string">"f5"</span>], <span class="attr">"command"</span>: <span class="string">"side_bar_files_open_with"</span>,</span><br><span class="line">         <span class="attr">"args"</span>: &#123;</span><br><span class="line">            <span class="attr">"paths"</span>: [],</span><br><span class="line">            <span class="attr">"application"</span>: <span class="string">"C:/Program Files/Internet Explorer/iexplore.exe"</span>,</span><br><span class="line">            <span class="attr">"extensions"</span>:<span class="string">" .*"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // chrome</span><br><span class="line">    &#123; <span class="attr">"keys"</span>: [<span class="string">"f6"</span>], <span class="attr">"command"</span>: <span class="string">"side_bar_files_open_with"</span>,</span><br><span class="line">        <span class="attr">"args"</span>: &#123;</span><br><span class="line">            <span class="attr">"paths"</span>: [],</span><br><span class="line">            <span class="attr">"application"</span>: <span class="string">"C:/Program Files (x86)/Google/Chrome/Application/chrome.exe"</span>,</span><br><span class="line">            <span class="attr">"extensions"</span>:<span class="string">".*"</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">    //删除多余空格</span><br><span class="line">    &#123; <span class="attr">"keys"</span>: [<span class="string">"ctrl+alt+d"</span>], <span class="attr">"command"</span>: <span class="string">"delete_trailing_spaces"</span> &#125;,</span><br><span class="line">    //是否开启TrailingSpacer</span><br><span class="line">    &#123; <span class="attr">"keys"</span>: [<span class="string">"ctrl+alt+o"</span>], <span class="attr">"command"</span>: <span class="string">"toggle_trailing_spaces"</span> &#125;,</span><br><span class="line">    //自动对齐</span><br><span class="line">    &#123; <span class="attr">"keys"</span>: [<span class="string">"ctrl+alt+shift+a"</span>], <span class="attr">"command"</span>: <span class="string">"alignment"</span> &#125;,</span><br><span class="line">    //文件夹中查找内容</span><br><span class="line">    &#123;<span class="attr">"keys"</span>:[<span class="string">"ctrl+alt+f"</span>], <span class="attr">"command"</span>: <span class="string">"show_panel"</span>, <span class="attr">"args"</span>: &#123;<span class="attr">"panel"</span>: <span class="string">"find_in_files"</span>&#125;&#125;,</span><br><span class="line"></span><br><span class="line">    //代码跳转</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"navigate_to_definition"</span>,</span><br><span class="line">        <span class="attr">"keys"</span>: [<span class="string">"ctrl+q"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"jump_prev"</span>,</span><br><span class="line">        <span class="attr">"keys"</span>: [<span class="string">"ctrl+e"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">     //一键格式化js代码</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"keys"</span>: [<span class="string">"ctrl+alt+l"</span>],</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"js_format"</span>,</span><br><span class="line">        <span class="attr">"context"</span>: [&#123;<span class="attr">"key"</span>: <span class="string">"selector"</span>, <span class="attr">"operator"</span>: <span class="string">"equal"</span>, <span class="attr">"operand"</span>: <span class="string">"source.js,source.json"</span>&#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><a href="#catalog"><p style="text-align: right">回到目录</p></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Sublime Text支持丰富的扩展及插件，使其在前端开发与编写动态语言时具有可以媲美IDE的效率。本文以Sublime Text3为例，分类别对常用插件进行简单的介绍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;建议：&lt;/strong&gt;阅读本文前，请先阅读&lt;a href=&quot;/2016/03/22/Sublime_basic/&quot;&gt;Sublime Text 入门篇&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;&lt;a name=&quot;catalog&quot;&gt;目录&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;#chart1&quot;&gt;1.  格式化（Format）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#chart2&quot;&gt;2.  智能提示（Intelligent Prompt）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#chart3&quot;&gt;3.  编码（Encoding）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#chart4&quot;&gt;4.  版本控制（Version Control）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#chart5&quot;&gt;5.  前端必备（Web UI）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#chart6&quot;&gt;6.  功能增强（Enhancement）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#chart7&quot;&gt;7.  个人插件快捷键配置（Personal Settings）&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://gitqh.github.io/categories/Tools/"/>
    
    
      <category term="Sublime Text" scheme="http://gitqh.github.io/tags/Sublime-Text/"/>
    
  </entry>
  
  <entry>
    <title>程序员开发利器软件篇（一）</title>
    <link href="http://gitqh.github.io/2017/09/11/Tools_software_I/"/>
    <id>http://gitqh.github.io/2017/09/11/Tools_software_I/</id>
    <published>2017-09-11T07:17:34.000Z</published>
    <updated>2015-07-29T12:42:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>用合适的工作做合适的事情，想成为一名高效的工程师，充分利用已有的工具可以帮你事半功倍。本系列计划分为硬件篇与软件篇，<br>旨在帮你打造Widows平台下的高效工作环境，希望能够为你节省工作中的点滴时间，去更好的享受生活。</p><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a><a name="catalog">目录</a></h2><p><a href="#chart1">1.  everything </a></p><p><a href="#chart2">2.  Filelocator Pro</a></p><p><a href="#chart3">3.  dexpot </a></p><p><a href="#chart4">4.  EmEditor </a></p><hr><a id="more"></a><h2 id="1-everything-（windows平台下的极速搜索神器）"><a href="#1-everything-（windows平台下的极速搜索神器）" class="headerlink" title="1.everything （windows平台下的极速搜索神器）"></a><a name="chart1">1.everything （windows平台下的极速搜索神器）</a></h2><p><strong> Everything</strong>是voidtools开发的一款运行于Windows系统，基于文件、文件夹名称的免费快速搜索引擎。</p><p>下载地址: <a href="http://www.voidtools.com/" target="_blank" rel="noopener">http://www.voidtools.com/</a></p><p>everything的特点主要有：体积小（几百K），搜索速度极快，占用系统资源少，监视文件系统更改。</p><p>everything的限制主要有：windows平台，仅限NTFS分区。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><ul><li><p>通配符 <code>*</code> 可以匹配任意长度和类型的字符。</p></li><li><p>通配符 <code>?</code> 可以匹配单个任意字符</p></li></ul><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>使用之前，确保已经打开正则表达式选项（菜单Search → Enable Regex）</p><ul><li><p><code>|</code> 竖线表示或。例如：gray|grey 能够匹配 gray或grey（注：在|两侧没有空格）</p></li><li><p><code>()</code> 小括号用于确定范围。例如：gr(a|e)表示在gr和y之间有一个字母a或e。gr(a|e)y将匹配gray或grey，与gray|grey意义相同。</p></li><li><p><code>?</code> 问号表示其前一个字符可能出现，也有可能不出现。例如：colou?r将匹配color和colour。</p></li><li><p><code>*</code> 星号表示其前一个字符可能不出现，也可能出现一次或多次。例如：ab*c将匹配ac、abc、abbc、abbbc等等。</p></li><li><p><code>+</code> 加号表示其前一个字符出现一次或多次。例如：ab+c将匹配abc、abbc、abbbc等等，但不能匹配ac。</p></li><li><p><code>.</code> 点号可用匹配任何单个非新行字符。（事实上，把哪个字符称之为新行却是不一定的，可能是编码特别或位置特别，但是可以肯定的是这个行中一定包含其他字符。）在POSIX括号表达式规则中，点号只* 匹配一个点。例如：a.c可以匹配abc等等字符，但是[a.c]只匹配a、.、或c。</p></li><li><p><code>[ ]</code> 中括号表示能够匹配其括号内出现的一个字符。例如：[abc]能够匹配a、b或c。[a-z]将能够匹配a到z之间的任意一个字符。[abcx-z]能够匹配a、b、c、x、y或z，其也可以表示成[a-cx-z]。</p></li><li><p><code>[^ ] [^ ]</code> 表示可以匹配任何一个没有出现在其括号内的字符，与[ ]刚好相反。例如：[^abc]能够匹配任何一个不是a、b、c的字符。[^a-z]能够匹配任何一个非小写字母之外的字符。</p></li><li><p><code>^</code> 匹配名称开始的位置。在以行为基础的工具中，匹配任意行的开始位置。</p></li><li><p><code>$</code> 匹配名称结束的位置，或者匹配字符串结尾新行的结束位置。在以行为基础的工具中，匹配任意行的结束位置。</p></li><li><p><code>{m,n} {m,n}</code> 表示其前面的字符至少重复m次，但是重复次数少于n。例如：a{3,5}匹配aaa、aaaa以及aaaaa，但是不能匹配aa或aaaaaa。此表达规则在一些老的版本中不可用</p></li></ul><p>界面功能区：</p><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/Tools_software_I_2015-07-29_18-48-22.png" alt=""></p><p>设置分区选项</p><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/Tools_software_I_2015-07-29_18-55-40.png" alt=""></p><p>文件过滤选项</p><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/Tools_software_I_2015-07-29_18-57-46.png" alt=""></p><p><a href="#catalog"><p style="text-align: right">回到目录</p></a></p><hr><h2 id="2-FileLocator-Pro（无索引全文检索工具）"><a href="#2-FileLocator-Pro（无索引全文检索工具）" class="headerlink" title="2. FileLocator Pro（无索引全文检索工具）"></a><a name="chart2">2. FileLocator Pro（无索引全文检索工具）</a></h2><p><strong> FileLocator Pro</strong> 是一款非常专业的搜索工具。不同于 Everything 和 Listary Pro 这类文件名快速索引工具， Filelocator Pro 不仅能搜索文件名，更擅长对指定文件和目录进行 全文搜索，并且支持 多种搜索表达式 以及 日期属性等 细节设定，快速准确定位您所需要的文档，提高搜索效率。</p><p>下载地址: <a href="http://mythicsoft.com/" target="_blank" rel="noopener">http://mythicsoft.com/</a></p><p>请注意，FileLocator Pro为收费软件，希望大家支持正版。</p><h3 id="Filelocator-Pro的特点主要有："><a href="#Filelocator-Pro的特点主要有：" class="headerlink" title="Filelocator Pro的特点主要有："></a>Filelocator Pro的特点主要有：</h3><ul><li>支持 50+ 常用文档格式的全文搜索</li></ul><p>FileLocator Pro 原生支持常见的 30+ 种 Office 文档以及 PDF 格式下的快速全文搜索，操作简单。如果安装 Microsoft Office 2010 筛选包 (官方推荐，点此下载) 还额外支持20余种格式，主要包括了 docx、docm、xlsx 等。</p><ul><li>对压缩包内文件进行深度搜索</li></ul><p>即便重要文档藏身于压缩文件内，FileLocator Pro 亦能毫无压力地对其进行全文搜索！软件支持 rar/zip/7z 等22种主流的压缩格式。对于那些经常打包文档发送邮件的办公人士来说，此功能无异雪中送炭。</p><ul><li>多种搜索表达式、规则</li></ul><p>FileLocator Pro 支持 6 种搜索规则，包括了 纯文本/布尔/正则 等，极大提高了搜索特定文档的灵活性。淡定，官方非常友好地为新手提供了详细的使用说明和简单易懂的“表达式向导”。亦或在全中文的帮助文档下，可让学习使用表达式的时间大大缩短，快速做到完全掌握，灵活搜索。</p><ul><li>内外兼得的文档查看器</li></ul><p>FileLocator Pro 自带的查看器可用于快速浏览符合搜索条件的文档，支持高亮显示关键词。对于高级用户，软件还预设了8种主流文本编辑器方案（ Vim/EditPlus/NotePad++ 等 ），可在搜索结束后直接调用。</p><ul><li>保存搜索条件 以及 导出搜索结果</li></ul><p>如果经常使用几个特定的搜索条件，可将它们保存至 .srf 格式，方便未来随时双击载入；FileLocator Pro 的收藏夹同样可以保存常用条件。同时，每次的搜索结果支持导出为 txt/CSV/HTML格式，方便处理存档。</p><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/Tools_software_I_2015-07-29_19-07-41.png" alt=""></p><p><a href="#catalog"><p style="text-align: right">回到目录</p></a></p><hr><h2 id="3-dexpot（超强虚拟桌面软件）"><a href="#3-dexpot（超强虚拟桌面软件）" class="headerlink" title="3. dexpot（超强虚拟桌面软件）"></a><a name="chart3">3. dexpot（超强虚拟桌面软件）</a></h2><p><strong> dexpot</strong>是一款来自德国的虚拟桌面工具，可以使Windows拥有可以匹敌MAC OS与Linux的多桌面工作环境。Dexpot最多可以支持20个虚拟<br>桌面，可以设置不同的壁纸及主题。</p><p>下载地址： <a href="http://dexpot.de/" target="_blank" rel="noopener">http://dexpot.de/</a></p><h3 id="dexpot的特点主要有："><a href="#dexpot的特点主要有：" class="headerlink" title="dexpot的特点主要有："></a>dexpot的特点主要有：</h3><ul><li>丰富的个性化设置</li></ul><p>Dexpot的使用很简单，而且最大的特点就是免费，最多可以开启20个虚拟桌面，有着丰富的设置，可以按照自己的喜好去使用。你还可以独立设置每一个虚拟桌面的分辨率、壁纸和屏保等个性化内容，也可以决定每个虚拟桌面要不要隐藏掉桌面图标，系统任务栏等。当然，你还可以根据自己的习惯设置快捷键，以便能高效使用。可以说 Dexpot 是非常的贴心。</p><ul><li>资源占用低</li></ul><p>Dexpot 完美支持主流的Windows7、Vista、XP操作系统，支持64位，对系统资源的占用也并不高，对于现在能跑Win7的电脑来说，它的资源占用估计可以忽略了，起码我见过在很多配置很低的机器上都能流畅跑。</p><p>设置界面：</p><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/Tools_software_I_2015-07-29_20-01-23.png" alt=""></p><p>设置效果：</p><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/Tools_software_I_2015-07-29_20-00-46.png" alt=""></p><p><a href="#catalog"><p style="text-align: right">回到目录</p></a></p><hr><h2 id="4-EmEditor-极简的大文本编辑器"><a href="#4-EmEditor-极简的大文本编辑器" class="headerlink" title="4. EmEditor(极简的大文本编辑器)"></a><a name="chart4">4. EmEditor(极简的大文本编辑器)</a></h2><p><strong> EmEditor</strong>是日本的江村软件公司（Emurasoft）所开发的一款在Windows平台上运行的文字编辑程式。EmEditor以运作轻巧、敏捷而又功能强大、丰富著称，得到许多用户的好评。</p><p>下载地址：<a href="https://zh-cn.emeditor.com/" target="_blank" rel="noopener">https://zh-cn.emeditor.com/</a></p><h3 id="EmEditor的特点主要有："><a href="#EmEditor的特点主要有：" class="headerlink" title="EmEditor的特点主要有："></a>EmEditor的特点主要有：</h3><ul><li>大文本编辑速度快</li></ul><p>启动、搜索和替换文本速度快，在编辑百兆或上G的文件时，速度超过大部分同类软件。</p><ul><li>自定义与宏功能</li></ul><p>EmEditor提供强大的自定义功能，可以在“工具”菜单设置文件关联、自定义菜单和工具栏、管理常用工具和插件等，点击“工具/自定义”可以打开自定义窗口（如图2），这里提供了众多选项，我们能够通过设置让EmEditor更加符合自己的使用习惯。</p><p>宏功能也是EmEditor一大亮点，比如需要书写相同的签名信息时，就可以在EmEditor中先录制一个签名信息的录入过程的宏，点击菜单栏中的“宏/开始停止录制”皆可开始录制，进行完录制动作后，点击同一按钮即可完成录制。当需要调用签名时，点击工具栏上的运行宏按钮便可以轻松完成。</p><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/Tools_software_I_2015-07-29_20-01-54.png" alt=""></p><p><a href="#catalog"><p style="text-align: right">回到目录</p></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用合适的工作做合适的事情，想成为一名高效的工程师，充分利用已有的工具可以帮你事半功倍。本系列计划分为硬件篇与软件篇，&lt;br&gt;旨在帮你打造Widows平台下的高效工作环境，希望能够为你节省工作中的点滴时间，去更好的享受生活。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;&lt;a name=&quot;catalog&quot;&gt;目录&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;#chart1&quot;&gt;1.  everything &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#chart2&quot;&gt;2.  Filelocator Pro&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#chart3&quot;&gt;3.  dexpot &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#chart4&quot;&gt;4.  EmEditor &lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://gitqh.github.io/categories/Tools/"/>
    
    
      <category term="Software" scheme="http://gitqh.github.io/tags/Software/"/>
    
  </entry>
  
  <entry>
    <title>解决Windows文件名过长无法删除问题</title>
    <link href="http://gitqh.github.io/2017/09/11/Windows_delete/"/>
    <id>http://gitqh.github.io/2017/09/11/Windows_delete/</id>
    <published>2017-09-11T07:17:34.000Z</published>
    <updated>2015-07-28T13:47:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在windows平台下学习yeoman的时候遇到一个问题，yeoman通过generator生成的项目中的依赖模块层级太深，无法删除。</p><p>借此机会，总结一下Windows下文件无法删除的解决方法。</p><hr><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Windows下文件无法删除的原因主要有以下两种：</p><ol><li><p>文件名称过长</p></li><li><p>文件目录嵌套过深</p></li></ol><hr><a id="more"></a><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul><li><p>Linux文件名的长度限制是255个字符</p></li><li><p>windows下完全限定文件名必须少于260个字符，目录名必须小于248个字符。</p></li></ul><hr><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="1-文件名称过长"><a href="#1-文件名称过长" class="headerlink" title="1. 文件名称过长"></a>1. 文件名称过长</h3><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/windows_delete_2015-07-26_17-46-38.png" alt=""></p><ul><li><p>在文件所在目录点击 <code>shift + 鼠标右键</code> ，选择<strong>在当前目录打开命令行窗口</strong></p></li><li><p>使用命令 <code>dir /x</code> ，显示系统长文件名对应的缩短文件名（在文件大小和原文件名之间会有一个缩短名称）</p></li></ul><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/windows_delete_2015-07-26_18-05-17.png" alt=""></p><ul><li>使用del命令+短文件名进行删除，删除后按 <code>F5</code> 进行刷新，可以发现文件已经被删掉了</li></ul><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/windows_delete_2015-07-26_18-06-25.png" alt=""></p><hr><h3 id="2-文件目录嵌套过深"><a href="#2-文件目录嵌套过深" class="headerlink" title="2. 文件目录嵌套过深"></a>2. 文件目录嵌套过深</h3><p>对于文件目录嵌套过深的问题，可以自上问下逐级修改文件夹名称为短名称，如”\1\1…”等，但如果文件数较多，使用该方法工作量就太大了，下面另辟蹊径，借用压缩软件<strong>winrar</strong>来解决该问题。</p><ul><li>安装<a href="http://www.winrar.com.cn/" target="_blank" rel="noopener">winrar</a>，右键点击待删除文件，选择添加到压缩文件</li></ul><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/windows_delete_2015-07-26_18-00-31.png" alt=""></p><ul><li>选择压缩后删除原来的文件</li></ul><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/windows_delete_2015-07-26_18-01-37.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在windows平台下学习yeoman的时候遇到一个问题，yeoman通过generator生成的项目中的依赖模块层级太深，无法删除。&lt;/p&gt;
&lt;p&gt;借此机会，总结一下Windows下文件无法删除的解决方法。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;Windows下文件无法删除的原因主要有以下两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;文件名称过长&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文件目录嵌套过深&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Windows" scheme="http://gitqh.github.io/categories/Windows/"/>
    
    
  </entry>
  
  <entry>
    <title>VMware通过NAT模式配置集群</title>
    <link href="http://gitqh.github.io/2016/03/22/VMware_Network/"/>
    <id>http://gitqh.github.io/2016/03/22/VMware_Network/</id>
    <published>2016-03-22T10:47:46.000Z</published>
    <updated>2017-07-19T01:27:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>进行分布式系统开发的过程中经常会需要构建分布式测试环境，本文主要介绍通过<strong>VMware</strong>构建一个分布式集群的虚拟环境并完成网络配置的全过程。</p><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a><a name="catalog">目录</a></h2><p><a href="#chart1">1.  背景知识 </a></p><p> VMWare提供了三种工作模式，它们是bridged(桥接模式)、NAT(网络地址转换模式)和host-only(主机模式)。</p><a id="more"></a><p>###1.bridged(桥接模式)</p><p>在这种模式下，VMWare虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问网内任何一台机器。在此种模式下，虚拟机内部的网卡（例如linux下的eth0)直接连到了物理网卡所在的网络上，可以想象为虚拟机和host机处于对等的地位，在网络关系上是平等的，没有谁在谁后面的问题。该种方式配置简单，但无法对虚拟机的网络进行控制，另外需要占用额外的IP地址，因此并不推荐选取该种方式进行实验。</p><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/VMware%E6%A1%A5%E6%8E%A5.jpg" alt=""></p><p>###2.host-only(主机模式)</p><p>在某些特殊的网络调试环境中，要求将真实环境和虚拟环境隔离开，这时你就可采用host-only模式。在host-only模式中，所有的虚拟系统是可以相互通信的，但虚拟系统和真实的网络是被隔离开的。</p><p>在host-only模式下，虚拟系统的TCP/IP配置信息(如IP地址、网关地址、DNS服务器等)，都是由VMnet1(host-only)虚拟网络的DHCP服务器来动态分配的。该种方式下虚拟机与主机通信使用虚拟网卡VMNet1，缺点是虚拟机不能访问公网。</p><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/VMwareHost-only.jpg" alt=""></p><p>###3.NAT(网络地址转换模式)</p><p>使用NAT模式，就是让虚拟系统借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。也就是说，使用NAT模式可以实现在虚拟系统里访问互联网。NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的，无法进行手工修改，因此虚拟系统也就无法和本局域网中的其他真实主机进行通讯。采用NAT模式最大的优势是虚拟系统接入互联网非常简单，你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可。</p><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/VMwareNAT.jpg" alt=""></p><p>提示：以上所提到的NAT模式下的VMnet8虚拟网络，host-only模式下的VMnet1虚拟网络，以及bridged模式下的VMnet0虚拟网络，都是由VMWare虚拟机自动配置而生成的，不需要用户自行设置。VMnet8和VMnet1提供DHCP服务，VMnet0虚拟网络则不提供。</p><hr><p><a href="#chart2">2.  实验目标 </a></p><p>构建基于NAT模式的虚拟机集群（包含3台虚拟机），并进行测试验证。</p><table><thead><tr><th style="text-align:right">虚拟机主机</th><th style="text-align:center">操作系统</th><th>IP地址</th></tr></thead><tbody><tr><td style="text-align:right">node1</td><td style="text-align:center">CentOS6.6</td><td>192.168.124.201</td></tr><tr><td style="text-align:right">node2</td><td style="text-align:center">CentOS6.6</td><td>192.168.124.202</td></tr><tr><td style="text-align:right">node3</td><td style="text-align:center">CentOS6.6</td><td>192.168.124.203</td></tr></tbody></table><p><a href="#chart3">3.  拷贝虚拟机 </a><br>　　<br>将一台已安装CentOS6.6的VMware虚拟机复制两次，并导入VMware。<br>虚拟机通过复制得到，会出现UUID冲突的问题，可通过以下方式解决：</p><p><em>1.删除mac地址行</em></p><pre><code>/etc/sysconfig/network-scripts/ifcfg-eth0</code></pre><p><em>2.删除网卡和mac地址绑定文件</em></p><pre><code>rm -rf /etc/udev/rules.d/70-persistent-net.rules</code></pre><p><em>3.重启系统</em></p><pre><code>shutdown -r</code></pre><hr><p><a href="#chart4">4.  修改主机名 </a></p><pre><code>vi /etc/hosts</code></pre><p>分别修改三台虚拟机主机名为node1，node2，node3，保存重启生效</p><hr><p><a href="#chart5">5.  修改网卡信息文件 </a></p><ol><li><p>查看本机VMnet8的ip相关信息，确定三台虚拟机的ip及网关，网关配置为VMnet8的ip（切记）</p></li><li><p>通过上述方式修改MAC地址信息，并配置IPADDR及NETMASK,以及GATEWAY，选择启OOTPROTO为none（默认static），选择启动网络时即启动网卡ONBOOT=yes，重启网络服务network。重启后可在虚拟机网络编辑器中确认网关及可用网段，如有问题，可直接修改。</p></li></ol><hr><p><a href="#chart6">6.  测试验证 </a></p><p>| Tables | Are | Cool | | ————- |:————-:| —–:| | col 3 is | right-aligned | $1600 | | col 2 is | centered | $12 | | zebra stripes | are neat | $1 |</p><hr><p><a href="#chart7">7.  常用命令 </a></p><pre><code>ifdown 网卡设备名 #禁用该网卡设备ifup 网卡设备名 #启用该网卡设备netstat 选项-t：列出TCP协议端口-u：列出UDP协议端口-n：不使用域名与服务名，而使用IP地址与端口号-l：列出在监听状态的网络服务-a：列出所用的网络连接traceroute [选项] IP或域名 #路由跟踪命令-n：使用IP，不使用域名，速度更快tcpdump -i eth0 -nnX port 21-i：指定网卡接口-nn：将数据包中的域名与服务转为IP和端口-X：以16进制和ASCII码显示数据包neirport：指定监听端口</code></pre><hr><p><a href="#chart8">8.  出现问题 </a></p><p>1.虚拟机找不到eth0网卡，出现原因：复制导致虚拟机会将源机的MAC地址作为eth0，后配置的MAC地址vmware会生成一个新网卡eth1,解决方式：打开文件/etc/udev/rules.d/70-persistent-net.rules，删除eth0相关信息，将eth1的NAME改为eth0，重启网络服务</p><p>2.虚拟机无法与主机通信，出现原因：vmware默认将网关配置为192.168.XX.2，局域网中没有该服务器<br>解决方式：修改vmware的网关配置，将其配置为本机的VMnet8网卡对应的IP</p><p>3.虚拟机的ip地址与配置的ip不一致，图像化桌面中出现auth eth0网卡。出现原因： 网卡信息文件ifcfg-eth0中有多余的HWADDR地址，与MAC地址不同。<br>解决方式：删除HWADDR行，重启网络服务</p><hr><p><a href="#chart9">9.  补充知识 </a></p><p>HWADDR以AA:BB:CC:DD:EE:FF形式表示以太网设备的硬件地址.在有多个网卡设备的机器上，这个字段是非常有用的，它保证设备接口被分配了正确的设备名 ，而不考虑每个网卡模块被配置的加载顺序.这个字段不能和MACADDR一起使用.</p><p>MACADDR以AA:BB:CC:DD:EE:FF形式表示以太网设备的硬件地址.在有多个网卡设备的机器上.这个字段用于给一个接口分配一个MAC地址，覆盖物理分配的MAC地址 . 这个字段不能和HWADDR一起使用.</p><p>前者是用来根据HWADDR绑定ethX名称的，后者才是真正用来修改MAC地址的</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进行分布式系统开发的过程中经常会需要构建分布式测试环境，本文主要介绍通过&lt;strong&gt;VMware&lt;/strong&gt;构建一个分布式集群的虚拟环境并完成网络配置的全过程。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;&lt;a name=&quot;catalog&quot;&gt;目录&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;#chart1&quot;&gt;1.  背景知识 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt; VMWare提供了三种工作模式，它们是bridged(桥接模式)、NAT(网络地址转换模式)和host-only(主机模式)。&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="http://gitqh.github.io/categories/Network/"/>
    
    
      <category term="VMware" scheme="http://gitqh.github.io/tags/VMware/"/>
    
  </entry>
  
  <entry>
    <title>Sublime Text 入门篇</title>
    <link href="http://gitqh.github.io/2016/03/22/Sublime_basic/"/>
    <id>http://gitqh.github.io/2016/03/22/Sublime_basic/</id>
    <published>2016-03-22T08:53:58.000Z</published>
    <updated>2016-03-22T08:53:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>Sublime Text作为一款优秀的跨平台（Linus、OS X、Windows）编辑器，因其具有可扩展性强，学习曲线平滑等优点，在前端开发中具有较为明显的优势。本文以Sublime Text3为例，与大家分享一些有关Sublime Text的经验与技巧。</p><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a><a name="catalog">目录</a></h2><p><a href="#chart1">1.  安装（Installation）</a></p><p><a href="#chart2">2.  窗口（Window）</a></p><p><a href="#chart3">3.  主题（Theme）</a></p><p><a href="#chart4">4.  编辑（Editing）</a></p><p><a href="#chart5">5.  插件（Plug-in）</a></p><p><a href="#chart6">6.  编码（Coding）</a></p><p><a href="#chart7">7.  快捷键（Shortcuts）</a></p><p><a href="#chart8">8.  引用（General）</a></p><hr><a id="more"></a><h2 id="安装（Installation）"><a href="#安装（Installation）" class="headerlink" title="安装（Installation）"></a><a name="chart1">安装（Installation）</a></h2><p>目前最新的版本是<a href="http://www.sublimetext.com/3" target="_blank" rel="noopener">Sublime Text3</a>，在Sublime官网可以下载，本文以windows环境下安装为例。注意，如果需要右键单击文件时能够直接使用Sublime Text打开，可在安装时勾选Add to explorer context menu。</p><h3 id="添加到App-Paths"><a href="#添加到App-Paths" class="headerlink" title="添加到App Paths"></a>添加到App Paths</h3><p>使用windows快捷键 <code>Win + R</code> 运行<strong>Regedit</strong>打开注册表，</p><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/Sublime_2015-07-13_23-47-12.png" alt=""></p><p>查找到目录<strong>HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows/CurrentVersion/App Paths</strong>，新建项，命名为sub.exe，项值填写sublime的安装位置（例如 C:\Program Files\Sublime Text 3\sublime_text.exe），</p><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/Sublime_2015-07-14_22-26-19.png" alt=""></p><p>之后可以使用windows快捷键 <code>Win + R</code>运行<strong>sub</strong>直接启动Sublime Text。</p><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/Sublime_2015-07-18_19-20-33.png" alt=""></p><h3 id="安装Package-Control"><a href="#安装Package-Control" class="headerlink" title="安装Package Control"></a>安装Package Control</h3><p>Package Control作为Sublime Text的插件管理器，可以方便的安装、查看、卸载Sublime Text中的插件，Sublime Text3安装方法如下：</p><ul><li><p>使用 <code>Ctrl + `</code> 打开Sublime Text控制台。</p></li><li><p>将下面的代码粘贴到控制台里：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request,os,hashlib; h = <span class="string">'7183a2d3e96f11eeadd761d777e62404'</span> + <span class="string">'e330c659d4bb41d3bdf022e94cab3cd0'</span>; pf = <span class="string">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( <span class="string">'http://sublime.wbond.net/'</span> + pf.replace(<span class="string">' '</span>, <span class="string">'%20'</span>)).read(); dh = hashlib.sha256(by).hexdigest(); print(<span class="string">'Error validating download (got %s instead of %s), please try manual install'</span> % (dh, h)) <span class="keyword">if</span> dh != h <span class="keyword">else</span> open(os.path.join( ipp, pf), <span class="string">'wb'</span> ).write(by)</span><br></pre></td></tr></table></figure><ul><li>安装完成后，使用 <code>Ctrl + Shift + P</code> 打开命令板，输入PC出现Package Control，可依照提示进行相应的操作。</li></ul><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/Sublime_2015-07-15-12-45.png" alt=""></p><p><a href="#catalog"><p style="text-align: right">回到目录</p></a></p><hr><h2 id="窗口与标签（Windows-And-Tabs）"><a href="#窗口与标签（Windows-And-Tabs）" class="headerlink" title="窗口与标签（Windows And Tabs）"></a><a name="chart2">窗口与标签（Windows And Tabs）</a></h2><p>Sublime Text是一个多窗口多标签编辑器，可以同时打开多个窗口，也可以在一个窗口中打开多个标签。（注：Sublime Text部分快捷键与搜狗输入法快捷键冲突，个人建议禁用全部搜狗输入法快捷键）。</p><h3 id="窗口（Window）"><a href="#窗口（Window）" class="headerlink" title="窗口（Window）"></a>窗口（Window）</h3><p>使用快捷键 <code>Ctrl + Shift + N</code> 创建一个新窗口；使用快捷键 <code>Alt + F4</code> 关闭Sublime Text</p><p>编码时分屏是最常用的功能，使用快捷键 <code>Alt + Shift + 2</code> 进行左右分屏， <code>Alt + Shift + 8</code> 进行上下分屏， <code>Alt + Shift + 5</code> 进行上下左右分屏（即分为四屏）。</p><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/Sublime_lAvhuX6.gif" alt=""></p><h3 id="标签（Tab）"><a href="#标签（Tab）" class="headerlink" title="标签（Tab）"></a>标签（Tab）</h3><p>标签部分的快捷键与大部分浏览器标签快捷键类似，使用 <code>Ctrl + N</code> 在当前窗口创建一个新标签， <code>Ctrl + W</code> 关闭当前标签， <code>Ctrl + Tab</code> 切换到下一个标签（右侧标签）， <code>Ctrl + Shift + Tab</code> 切换到上一个标签（左侧标签）， <code>Ctrl + Shift + T</code> 恢复刚关闭的标签。</p><p><a href="#catalog"><p style="text-align: right">回到目录</p></a></p><hr><h2 id="主题（Theme）"><a href="#主题（Theme）" class="headerlink" title="主题（Theme）"></a><a name="chart3">主题（Theme）</a></h2><p>Sublime Text有很多第三方主题：<a href="[https://sublime.wbond.net/browse/labels/theme]">[https://sublime.wbond.net/browse/labels/theme]</a>，可按照自己喜好下载</p><h3 id="设置（Settings）"><a href="#设置（Settings）" class="headerlink" title="设置（Settings）"></a>设置（Settings）</h3><p>可增加如下设置，优化显示效果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 设置Sans-serif（无衬线）等宽字体，以便阅读</span><br><span class="line">"font_face": "YaHei Consolas Hybrid",</span><br><span class="line">"font_size": 12,</span><br><span class="line">// 使光标闪动更加柔和</span><br><span class="line">"caret_style": "phase",</span><br><span class="line">// 高亮当前行</span><br><span class="line">"highlight_line": true,</span><br><span class="line">// 高亮有修改的标签</span><br><span class="line">"highlight_modified_tabs": true,</span><br></pre></td></tr></table></figure><hr><h2 id="编辑（Editing）"><a href="#编辑（Editing）" class="headerlink" title="编辑（Editing）"></a><a name="chart4">编辑（Editing）</a></h2><h3 id="文件夹（Folders）"><a href="#文件夹（Folders）" class="headerlink" title="文件夹（Folders）"></a>文件夹（Folders）</h3><p>Sublime Text在 <code>File</code> 下选择 <code>Open Folder</code> 可以打开侧边栏，侧边栏列出了当前打开的文件和文件夹的文件，使用 <code>Ctrl + K</code> , <code>Ctrl + B</code> 显示或隐藏侧栏，使用 <code>Ctrl + P</code> 可以快速跳转到文件夹里的文件。</p><h3 id="基本操作-Basic-Operation"><a href="#基本操作-Basic-Operation" class="headerlink" title="基本操作(Basic Operation)"></a>基本操作(Basic Operation)</h3><p><code>Ctrl + Enter</code> 在当前行下面新增一行然后跳至该行； <code>Ctrl + Shift + Enter</code> 在当前行上面增加一行并跳至该行。</p><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/Sublime_rvzS9Ok.gif" alt=""></p><p><code>Ctrl + ←/→</code> 进行逐词移动，相应的， <code>Ctrl + Shift + ←/→</code> 进行逐词选择。</p><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/Sublime_jFnTDl3.gif" alt=""></p><p><code>Ctrl + ↑/↓</code> 移动当前显示区域， <code>Ctrl + Shift + ↑/↓</code> 移动当前行。</p><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/Sublime_v31pd3k.gif" alt=""></p><p><code>alt + .</code> ：自动补全标签</p><p><code>Ctrl + d</code> :删除整行</p><h3 id="选择（Selecting）"><a href="#选择（Selecting）" class="headerlink" title="选择（Selecting）"></a>选择（Selecting）</h3><p>Sublime Text的一大亮点是支持多重选择——同时选择多个区域，然后同时进行编辑。</p><p><code>Ctrl + D</code> 选择当前光标所在的词并高亮该词所有出现的位置，再次 <code>Ctrl + D</code> 选择该词出现的下一个位置，在多重选词的过程中，使用 <code>Ctrl + K</code> 进行跳过，使用 <code>Ctrl + U</code> 进行回退，使用 <code>Esc</code> 退出多重编辑。</p><p><code>Ctrl + Shift + L</code> 可以将当前选中区域打散，然后进行同时编辑， <code>Ctrl + J</code> 可以把当前选中区域合并为一行。</p><h3 id="查找替换（Finding-And-Replacing）"><a href="#查找替换（Finding-And-Replacing）" class="headerlink" title="查找替换（Finding And Replacing）"></a>查找替换（Finding And Replacing）</h3><p>Sublime Text的查找功能主要包括<strong>快速查找</strong>、<strong>标准查找</strong>和<strong>文件夹查找</strong>三种类型。</p><h4 id="快速查找替换"><a href="#快速查找替换" class="headerlink" title="快速查找替换"></a>快速查找替换</h4><p>我们可以使用 <code>Shift + ←/→</code> 或 <code>Ctrl + D</code> 选中关键字，然后 <code>F3</code> 跳到其下一个出现位置， <code>Shift + F3</code> 跳到其上一个出现位置，此外还可以用 <code>Alt + F3</code> 选中其出现的所有位置（之后可以进行多重编辑，也就是快速替换）。</p><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/Sublime_6AaBiRS.jpg" alt=""></p><h4 id="标准查找替换"><a href="#标准查找替换" class="headerlink" title="标准查找替换"></a>标准查找替换</h4><p>当搜索某个已知但不在当前显示区域的关键字，这时可以使用 <code>Ctrl + F</code> 调出搜索框进行搜索，使用 <code>Ctrl + H</code> 进行替换。</p><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/Sublime_4NnE9SN.jpg" alt=""></p><h5 id="关键字查找替换"><a href="#关键字查找替换" class="headerlink" title="关键字查找替换"></a>关键字查找替换</h5><p>在搜索框输入关键字后 <code>Enter</code> 跳至关键字当前光标的下一个位置， <code>Shift + Enter</code> 跳至上一个位置，<code>Alt + Enter</code> 选中其出现的所有位置。</p><p>Sublime Text的查找有不同的模式： <code>Alt + C</code> 切换大小写敏感（Case-sensitive）模式， <code>Alt + W</code> 切换整字匹配（Whole matching）模式，除此之外Sublime Text还支持在选中范围内搜索（Search in selection），这个功能没有对应的快捷键，但可以通过以下配置项自动开启:</p><p><code>&quot;auto_find_in_selection&quot;: true</code></p><h5 id="正则表达式查找替换"><a href="#正则表达式查找替换" class="headerlink" title="正则表达式查找替换"></a>正则表达式查找替换</h5><p>Sublime Text中使用 <code>Alt + R</code> 切换正则匹配模式的开启/关闭。Sublime Text的使用<a href="http://www.boost.org/doc/libs/1_44_0/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html" target="_blank" rel="noopener">Boost里的Perl正则表达式风格</a>。</p><p>关于正则表达式本文不做详述，请参照<a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">正则表达式30分钟入门教程</a>。</p><h4 id="文件夹查找替换"><a href="#文件夹查找替换" class="headerlink" title="文件夹查找替换"></a>文件夹查找替换</h4><p>使用 <code>Ctrl + Shift + F</code> 开启文件夹查找替换（注意此快捷键和搜狗输入法的简繁切换快捷键有冲突）。</p><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/Sublime_05Fchle.jpg" alt=""></p><h3 id="跳转（Jumping）"><a href="#跳转（Jumping）" class="headerlink" title="跳转（Jumping）"></a>跳转（Jumping）</h3><p>实际编码中，跳转是非常实用的一个功能，可以有效的帮你脱离鼠标，更快的提高工作效率。跳转主要分为<strong>跳转到文件</strong>、<strong>跳转到符号</strong>、<strong>跳转到某行</strong>、<strong>组合跳转</strong>四中类型。</p><h4 id="跳转到文件"><a href="#跳转到文件" class="headerlink" title="跳转到文件"></a>跳转到文件</h4><p><code>Ctrl + P</code> 会列出当前打开的文件（或者是当前文件夹的文件），输入文件名然后 <code>Enter</code> 跳转至该文件。</p><p>需要注意的是，Sublime Text使用模糊字符串匹配（Fuzzy String Matching），可以通过文件名的前缀、首字母或是某部分进行匹配：例如，<code>EIS</code> 、 <code>Eclip</code> 和 <code>Stupid</code> 都可以匹配 <code>EclipseIsStupid.java</code> 。</p><h4 id="跳转到符号"><a href="#跳转到符号" class="headerlink" title="跳转到符号"></a>跳转到符号</h4><p><code>Ctrl + R</code> 可以列出当前文件中的符号（例如类名和函数名，但无法精确到变量名），输入符号名称 <code>Enter</code> 即可以跳转到该处。此外，还可以使用 <code>F12</code> 快速跳转到当前光标所在符号的定义处。</p><h4 id="跳转到某行"><a href="#跳转到某行" class="headerlink" title="跳转到某行"></a>跳转到某行</h4><p><code>Ctrl + G</code> 然后输入行号以跳转到指定行</p><h4 id="组合跳转"><a href="#组合跳转" class="headerlink" title="组合跳转"></a>组合跳转</h4><p>在 <code>Ctrl + P</code> 匹配到文件后，我们可以进行后续输入以跳转到更精确的位置：</p><ul><li><p><code>@</code> 符号跳转：输入 <code>@symbol</code> 跳转到 <code>symbol</code> 符号所在的位置</p></li><li><p><code>#</code> 关键字跳转：输入 <code>#keyword</code> 跳转到 <code>keyword</code> 所在的位置</p></li><li><p><code>:</code> 行号跳转：输入 <code>:80</code> 跳转到文件的第80行。</p></li></ul><p><a href="#catalog"><p style="text-align: right">回到目录</p></a></p><hr><h2 id="插件（Plug-in）"><a href="#插件（Plug-in）" class="headerlink" title="插件（Plug-in）"></a><a name="chart5">插件（Plug-in）</a></h2><p>请参照<a href="/2016/03/22/Sublime_plugin">Sublime Text插件篇</a>。</p><p><a href="#catalog"><p style="text-align: right">回到目录</p></a></p><hr><h2 id="编码（Coding）"><a href="#编码（Coding）" class="headerlink" title="编码（Coding）"></a><a name="chart6">编码（Coding）</a></h2><h3 id="代码规范（Code-Style-Guideline）"><a href="#代码规范（Code-Style-Guideline）" class="headerlink" title="代码规范（Code Style Guideline）"></a>代码规范（Code Style Guideline）</h3><p>可参照如下进行设置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 设置tab的大小为2</span><br><span class="line">"tab_size": 2,</span><br><span class="line">// 使用空格代替tab</span><br><span class="line">"translate_tabs_to_spaces": true,</span><br><span class="line">// 添加行宽标尺</span><br><span class="line">"rulers": [80, 100],</span><br><span class="line">// 显示空白字符</span><br><span class="line">"draw_white_space": "all",</span><br><span class="line">// 保存时自动去除行末空白</span><br><span class="line">"trim_trailing_white_space_on_save": true,</span><br><span class="line">// 保存时自动增加文件末尾换行</span><br><span class="line">"ensure_newline_at_eof_on_save": true,</span><br></pre></td></tr></table></figure><h3 id="格式化（Formatting）"><a href="#格式化（Formatting）" class="headerlink" title="格式化（Formatting）"></a>格式化（Formatting）</h3><p>Sublime Text基本的手动格式化操作包括： <code>Ctrl + [</code> 向左缩进， <code>Ctrl + ]</code> 向右缩进，此外 <code>Ctrl + Shift + V</code> 可以以当前缩进粘贴代码。</p><h3 id="自动完成（Auto-Completion）"><a href="#自动完成（Auto-Completion）" class="headerlink" title="自动完成（Auto Completion）"></a>自动完成（Auto Completion）</h3><p>Sublime Text 支持一定的自动完成，按 <code>Tab</code> 自动补全。</p><h3 id="括号（Brackets）"><a href="#括号（Brackets）" class="headerlink" title="括号（Brackets）"></a>括号（Brackets）</h3><p>编写代码时会碰到大量的括号，利用 <code>Ctrl + M</code> 可以快速的在起始括号和结尾括号间切换， <code>Ctrl + Shift + M</code> 则可以快速选择括号间的内容，对于缩进型语言（例如Python）则可以使用 <code>Ctrl + Shift + J</code> 。</p><p><img src="http://7xkd5g.com1.z0.glb.clouddn.com/Sublime_oxWjAo9.gif" alt=""></p><p><a href="#catalog"><p style="text-align: right">回到目录</p></a></p><hr><h2 id="快捷键（Shortcuts）"><a href="#快捷键（Shortcuts）" class="headerlink" title="快捷键（Shortcuts）"></a><a name="chart7">快捷键（Shortcuts）</a></h2><p>下面列出的快捷键为windows平台下的快捷键，Linux与OS X快捷键请参考<a href="http://sublime-text-unofficial-documentation.readthedocs.org/en/latest/reference/keyboard_shortcuts_win.html" target="_blank" rel="noopener">Windows/Linux快捷键</a>和<a href="http://sublime-text-unofficial-documentation.readthedocs.org/en/latest/reference/keyboard_shortcuts_osx.html" target="_blank" rel="noopener">OS X快捷键</a>。</p><h3 id="通用（General）"><a href="#通用（General）" class="headerlink" title="通用（General）"></a>通用（General）</h3><ul><li><p><code>↑↓←→</code> :上下左右移动光标</p></li><li><p><code>Alt</code> :调出菜单</p></li><li><p><code>Ctrl + Shift + P</code> :调出命令板（Command Palette）</p></li><li><p><code>Ctrl + `</code> :调出控制台</p></li></ul><h3 id="编辑（Editing）-1"><a href="#编辑（Editing）-1" class="headerlink" title="编辑（Editing）"></a>编辑（Editing）</h3><ul><li><p><code>Ctrl + Enter</code> :在当前行下面新增一行然后跳至该行</p></li><li><p><code>Ctrl + Shift + Enter</code> :在当前行上面增加一行并跳至该行</p></li><li><p><code>Ctrl + ←/→</code> :进行逐词移动</p></li><li><p><code>Ctrl + Shift + ←/→</code> :进行逐词选择</p></li><li><p><code>Ctrl + ↑/↓</code> :移动当前显示区域</p></li><li><p><code>Ctrl + Shift + ↑/↓</code> :移动当前行</p></li></ul><h3 id="选择（Selecting）-1"><a href="#选择（Selecting）-1" class="headerlink" title="选择（Selecting）"></a>选择（Selecting）</h3><ul><li><p><code>Ctrl + D</code> :选择当前光标所在的词并高亮该词所有出现的位置，再次Ctrl + D选择该词出现的下一个位置，在多重选词的过程中，使用 <code>Ctrl + K</code> 进行跳过，使用 <code>Ctrl + U</code> 进行回退，使用 <code>Esc</code> 退出多重编辑</p></li><li><p><code>Ctrl + Shift + L</code> :将当前选中区域打散</p></li><li><p><code>Ctrl + J</code> :把当前选中区域合并为一行</p></li><li><p><code>Ctrl + M</code> :在起始括号和结尾括号间切换</p></li><li><p><code>Ctrl + Shift + M</code> :快速选择括号间的内容</p></li><li><p><code>Ctrl + Shift + J</code> :快速选择同缩进的内容</p></li><li><p><code>Ctrl + Shift + Space</code> :快速选择当前作用域（Scope）的内容</p></li></ul><h3 id="查找替换（Finding-And-Replacing）-1"><a href="#查找替换（Finding-And-Replacing）-1" class="headerlink" title="查找替换（Finding And Replacing）"></a>查找替换（Finding And Replacing）</h3><ul><li><p><code>F3</code> :跳至当前关键字下一个位置</p></li><li><p><code>Shift + F3</code> :跳到当前关键字上一个位置</p></li><li><p><code>Alt + F3</code> :选中当前关键字出现的所有位置</p></li><li><p><code>Ctrl + Shift + F</code> :多文件搜索及替换</p></li><li><p><code>Ctrl + F/H</code> :进行标准查找/替换，之后` :</p><ul><li><p><code>Alt + C</code> :切换大小写敏感（Case-sensitive）模式</p></li><li><p><code>Alt + W</code> :切换整字匹配（Whole matching）模式</p></li><li><p><code>Alt + R</code> :切换正则匹配（Regex matching）模式</p></li><li><p><code>Ctrl + Shift + H</code> :替换当前关键字</p></li><li><p><code>Ctrl + Alt + Enter</code> :替换所有关键字匹配</p></li></ul></li></ul><h3 id="跳转（Jumping）-1"><a href="#跳转（Jumping）-1" class="headerlink" title="跳转（Jumping）"></a>跳转（Jumping）</h3><ul><li><p><code>Ctrl + P</code> :跳转到指定文件，输入文件名后可以` :</p><ul><li><p><code>@ 符号跳转</code> :输入@symbol跳转到symbol符号所在的位置</p></li><li><p><code># 关键字跳转</code> :输入#keyword跳转到keyword所在的位置</p></li><li><p><code>: 行号跳转</code> :输入:12跳转到文件的第12行。</p></li></ul></li><li><p><code>Ctrl + R</code> :跳转到指定符号</p></li><li><p><code>Ctrl + G</code> :跳转到指定行号</p></li></ul><h3 id="窗口（Window）-1"><a href="#窗口（Window）-1" class="headerlink" title="窗口（Window）"></a>窗口（Window）</h3><ul><li><p><code>Ctrl + Shift + N</code> :创建一个新窗口</p></li><li><p><code>Ctrl + N</code> :在当前窗口创建一个新标签</p></li><li><p><code>Ctrl + W</code> :关闭当前标签，当窗口内没有标签时会关闭该窗口</p></li><li><p><code>Ctrl + Shift + T</code> :恢复刚刚关闭的标签</p></li><li><p><code>Ctrl + Tab</code> :切换到下一个标签（右侧标签）</p></li><li><p><code>Ctrl + Shift + Tab</code> :切换到上一个标签（左侧标签）</p></li><li><p><code>Ctrl + Shift + T</code> :恢复刚刚关闭的标签</p></li></ul><h3 id="屏幕（Screen）"><a href="#屏幕（Screen）" class="headerlink" title="屏幕（Screen）"></a>屏幕（Screen）</h3><ul><li><p><code>F11</code> :切换普通全屏</p></li><li><p><code>Shift + F11</code> :切换无干扰全屏</p></li><li><p><code>Alt + Shift + 2</code> :进行左右分屏</p></li><li><p><code>Alt + Shift + 8</code> :进行上下分屏</p></li><li><p><code></code>Alt + Shift + 5<code>:</code>进行上下左右分屏<br>分屏之后，使用Ctrl + 数字键跳转到指定屏，使用Ctrl + Shift + 数字键将当前屏移动到指定屏</p></li></ul><p><a href="#catalog"><p style="text-align: right">回到目录</p></a></p><hr><h2 id="引用（Reference）"><a href="#引用（Reference）" class="headerlink" title="引用（Reference）"></a><a name="chart8">引用（Reference）</a></h2><p>本文撰写的过程中，参考了以下几位博主的文章，在此附上引用，并致谢：</p><ul><li><p><a href="http://www.cnblogs.com/figure9/p/sublime-text-complete-guide.html" target="_blank" rel="noopener">http://www.cnblogs.com/figure9/p/sublime-text-complete-guide.html</a></p></li><li><p><a href="http://caibaojian.com/sublime-text2-toturial.html" target="_blank" rel="noopener">http://caibaojian.com/sublime-text2-toturial.html</a></p></li><li><p><a href="http://lucifr.com/2011/08/31/sublime-text-2-tricks-and-tips/" target="_blank" rel="noopener">http://lucifr.com/2011/08/31/sublime-text-2-tricks-and-tips/</a></p></li></ul><p><a href="#catalog"><p style="text-align: right">回到目录</p></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Sublime Text作为一款优秀的跨平台（Linus、OS X、Windows）编辑器，因其具有可扩展性强，学习曲线平滑等优点，在前端开发中具有较为明显的优势。本文以Sublime Text3为例，与大家分享一些有关Sublime Text的经验与技巧。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;&lt;a name=&quot;catalog&quot;&gt;目录&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;#chart1&quot;&gt;1.  安装（Installation）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#chart2&quot;&gt;2.  窗口（Window）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#chart3&quot;&gt;3.  主题（Theme）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#chart4&quot;&gt;4.  编辑（Editing）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#chart5&quot;&gt;5.  插件（Plug-in）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#chart6&quot;&gt;6.  编码（Coding）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#chart7&quot;&gt;7.  快捷键（Shortcuts）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#chart8&quot;&gt;8.  引用（General）&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://gitqh.github.io/categories/Tools/"/>
    
    
      <category term="Sublime Text" scheme="http://gitqh.github.io/tags/Sublime-Text/"/>
    
  </entry>
  
</feed>
